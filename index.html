<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>던파 아이템 유효성 검사기</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Malgun Gothic", "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        .container {
            /* max-width: 900px; */
            margin: 0 auto;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        h1 {
            color: #1a1a1a;
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .input-area {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            max-width: 400px;
        }
        #characterNameInput {
            flex-grow: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        #searchButton {
            padding: 10px 20px;
            border: none;
            background-color: #007bff;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #searchButton:hover {
            background-color: #0056b3;
        }
        #searchButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
            color: #555;
            font-weight: bold;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .results-table th, .results-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-size: 14px;
        }
        .results-table th {
            background-color: #f9f9f9;
        }
        .valid-true {
            color: #28a745;
            font-weight: bold;
        }
        .valid-false {
            color: #dc3545;
        }
        /* 확률 셀 스타일 */
.probability-cell {
    font-weight: bold;
    text-align: center !important;
    padding: 8px;
    border-radius: 4px;
}

/* 4구간 스타일 정의 (0%~100%) */

/* 구간 1: 0% ~ 25% (가장 낮은 확률, 나쁨 - 빨강/주황) */
.prob-low {
    background-color: #ff9999; /* 밝은 빨강 */
    color: #800000;
}

/* 구간 2: 26% ~ 50% (보통 - 노랑) */
.prob-mid-low {
    background-color: #ffda6a; /* 노란색 */
    color: #995c00;
}

/* 구간 3: 51% ~ 75% (좋음 - 연두) */
.prob-mid-high {
    background-color: #b3e6b3; /* 밝은 녹색 */
    color: #004d00;
}

/* 구간 4: 76% ~ 100% (가장 높은 확률, 매우 좋음 - 파랑/초록) */
.prob-high {
    background-color: #8cd98c; /* 진한 녹색 */
    color: #003300;
}
    </style>
</head>
<body>

    <div class="container">
        <h1>아이템 획득 유효성 검사기</h1>
        <div class="input-area">
            <input type="text" id="characterNameInput" placeholder="캐릭터명을 입력하세요 (서버: 카인)">
            <button id="searchButton" onclick="startSearch()">조회</button>
        </div>
        
        <div id="rarityFilters" style="margin-top: 15px;">
    <label>
        <input type="checkbox" id="filterTaecho" value="태초" onchange="filterTimeline()" checked> 태초
    </label>
    <label>
        <input type="checkbox" id="filterEpic" value="에픽" onchange="filterTimeline()" checked> 에픽
    </label>
    <label>
        <input type="checkbox" id="filterLegendary" value="레전더리" onchange="filterTimeline()" checked> 레전더리
    </label>
    </div>
        
        <div id="status"></div>
        <table class="results-table">
            <thead>
                <tr>
                    <th>획득 시간</th>
                    <th>아이템명</th>
                    <th>등급</th>
                    <th>세트</th>
                    <th>부위</th>
                    <th>유효 확률</th>
                    <th>유효 여부</th>
                </tr>
            </thead>
            <tbody id="resultsContainer">
                </tbody>
        </table>
    </div>

    <script>
// 🚨 모든 타임라인 데이터를 저장할 전역 변수 🚨
let allTimelinePages = [];
let filteredTimelinePages = [];
        
        // 전역 캐시 객체: 아이템 ID를 키(Key)로, 아이템 상세 정보를 값(Value)으로 저장
        const itemDetailsCache = {};
        
        // 🚨 아이템 획득 시점까지의 세트 부위 점유 상태를 추적하는 객체
// Key: "세트이름-희귀도" (예: "세렌디피티 세트-에픽")
// Value: Set 객체로, 이미 획득한 슬롯 부위 이름들을 저장합니다.
const setSlotTracker = {};

        // 🚨 희귀도 순위 정의 (높을수록 낮은 순위 값) 🚨
// 비교를 위해 순위를 부여합니다.
const RARITY_RANK = {
    '태초': 1,
    '에픽': 2,
    '레전더리': 3 
    // 무기는 제외, 나머지 희귀도는 VALID_RARITIES에서 제외
};
        
        // 전체 세트 부위 수 (무기 제외 11개)
const TOTAL_SET_SLOTS = 11; 
// 유효 희귀도 목록
const VALID_RARITIES = ['태초', '에픽', '레전더리'];

        // 🚨 태초 아이템의 실제 세트 부위 (액세서리 3종) 🚨
const TAECHO_SLOTS = ['팔찌', '목걸이', '반지'];
const MAX_TAECHO_SLOTS = TAECHO_SLOTS.length; // 3
        
        // --- 설정 및 상수 ---
// *** 프록시 서버의 기본 경로를 정의합니다. ***
// Vercel에 배포된 경우, /api/proxy는 api/proxy.js 서버리스 함수로 연결됩니다.
const PROXY_BASE_URL = "/api/proxy/df"; // Neople API의 /df 이전 경로를 프록시로 지정
        
        const SERVER_ID = "cain";
        
        // 아이템 등급 우선순위 (높을수록 좋음)
        const RARITY_ORDER = {
            "태초": 3,
            "에픽": 2,
            "레전더리": 1
        };

        // --- DOM 요소 ---
        const charInput = document.getElementById('characterNameInput');
        const searchBtn = document.getElementById('searchButton');
        const statusEl = document.getElementById('status');
        const resultsEl = document.getElementById('resultsContainer');

        /**
 * 캐릭터명 입력창에서 Enter 키를 눌렀을 때 startSearch() 함수를 호출합니다.
 * @param {Event} event - 키보드 이벤트 객체
 */
function handleEnterKey(event) {
    // Enter 키의 keyCode는 13입니다.
    if (event.key === 'Enter' || event.keyCode === 13) {
        event.preventDefault(); // 기본 Enter 동작(폼 제출 등) 방지
        startSearch();         // 조회 시작 함수 호출
    }
}

        // --- API 호출 함수 ---

        // 1. 캐릭터 ID 조회
        async function getCharacterId(characterName) {
            const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters?characterName=${encodeURIComponent(characterName)}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error("캐릭터 ID 조회 실패");
            const data = await response.json();
            if (!data.rows || data.rows.length === 0) throw new Error("캐릭터를 찾을 수 없습니다.");
            return data.rows[0].characterId;
        }

        // 2. 타임라인 조회 (월별로 반복 호출)
        async function getAllTimelinePages(characterId) {
            let allTimelineRows = [];
            let currentMonthStart = new Date('2025-01-01');
            const today = new Date();

            while (currentMonthStart < today) {
                // 다음 달 1일 계산
                let nextMonthStart = new Date(currentMonthStart.getFullYear(), currentMonthStart.getMonth() + 1, 1);
                if (nextMonthStart > today) {
                    nextMonthStart = today;
                }
                
                // 날짜 포맷팅 (YYYYMMDD)
                const startDateStr = formatDate(currentMonthStart);
                const endDateStr = nextMonthStart === today ? formatDate(nextMonthStart) + formatToApiTime(nextMonthStart) : formatDate(nextMonthStart);

                statusEl.textContent = `${currentMonthStart.getFullYear()}년 ${currentMonthStart.getMonth() + 1}월 타임라인 조회 중...`;
                
                const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters/${characterId}/timeline?limit=100&code=505,507,513&startDate=${startDateStr}&endDate=${endDateStr}`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.timeline && data.timeline.rows) {
                        allTimelineRows.push(...data.timeline.rows);
                    }
                } catch (e) {
                    console.error(`${startDateStr} 타임라인 조회 실패:`, e);
                    // 한두 달 실패해도 계속 진행
                }

                // 다음 달로 이동
                currentMonthStart = nextMonthStart;
            }

            const allItemIds = [];
    allTimelineRows.forEach(row => {
            if (row.data && row.data.itemId) {
                // itemId가 쉼표로 분리되어 있을 수 있으므로 모두 추출
                const ids = row.data.itemId.split(',').map(id => id.trim()).filter(id => id.length > 0);
                allItemIds.push(...ids);
            }
        });

    // 수집된 모든 아이템 ID에 대해 다중 조회 함수 호출
    await getTimelineItemDetails(allItemIds);
            return allTimelineRows;
        }

// ⚠️ 추가: API가 요구하는 hhmm 형식으로 시간을 포맷하는 헬퍼 함수
function formatToApiTime(date) {
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `T${hh}${mm}`;
}

        // 기존: getItemDetails(itemId)를 대체하는 함수
// 타임라인에서 필요한 모든 아이템 ID 목록을 받아 정보를 조회하고 캐시에 저장합니다.
async function getTimelineItemDetails(allItemIds) {
    const uniqueItemIds = Array.from(new Set(allItemIds));
    const itemIdsToFetch = [];
    
    // 1. 캐시 확인 및 조회할 목록 분류
    for (const itemId of uniqueItemIds) {
        if (!itemDetailsCache[itemId]) {
            itemIdsToFetch.push(itemId); // 캐시에 없는 아이템만 조회 목록에 추가
        }
    }

    if (itemIdsToFetch.length === 0) {
        console.log("[Multi-Fetch] All items found in cache.");
        return; // 조회할 아이템이 없으면 종료
    }

    console.log(`[Multi-Fetch] Need to fetch ${itemIdsToFetch.length} items.`);

    // 2. 아이템 ID를 최대 15개씩 묶어 API 호출
    const CHUNK_SIZE = 15;
    const fetchPromises = [];

    for (let i = 0; i < itemIdsToFetch.length; i += CHUNK_SIZE) {
        const chunk = itemIdsToFetch.slice(i, i + CHUNK_SIZE);
        const itemIdsParam = chunk.join(','); // 아이템 ID들을 콤마로 연결

        // 다중 조회 API URL
        const url = `${PROXY_BASE_URL}/multi/items?itemIds=${encodeURIComponent(itemIdsParam)}`;
        
        // 프록시 서버에 요청을 보내고 Promise를 배열에 저장
        fetchPromises.push(
            fetch(url)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`다중 아이템 조회 실패: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // 3. 응답 데이터를 파싱하여 캐시에 저장
                if (data.rows) {
                    for (const itemData of data.rows) {
                        const itemId = itemData.itemId;
                        itemDetailsCache[itemId] = itemData; // 캐시 업데이트
                    }
                }
            })
            .catch(error => {
                console.error(`아이템 묶음 조회 중 오류 발생: ${error.message}`);
                // 오류 발생 시 해당 아이템들의 캐시 항목은 undefined로 남습니다.
            })
        );
    }

    // 4. 모든 API 호출이 완료될 때까지 기다립니다.
    await Promise.all(fetchPromises);
}

        // 3. 아이템 상세 정보 조회 (캐시 사용)
        const itemDetailCache = new Map();
        async function getItemDetails(itemId) {
            if (itemDetailCache.has(itemId)) {
                return itemDetailCache.get(itemId);
            }
            
            const url = `${PROXY_BASE_URL}/items/${itemId}`;
            try {
                const response = await fetch(url);
                if (!response.ok) return null; // 조회 실패 시 null 반환
                const data = await response.json();
                itemDetailCache.set(itemId, data); // 캐시에 저장
                return data;
            } catch (e) {
                console.error(`아이템(${itemId}) 상세 조회 실패:`, e);
                return null;
            }
        }

        // --- 메인 로직 ---
         async function startSearch() {
            const characterName = charInput.value.trim();
            if (!characterName) {
                alert("캐릭터명을 입력해주세요.");
                return;
            }

            // 초기화
            searchBtn.disabled = true;
            statusEl.textContent = "조회를 시작합니다...";
            resultsEl.innerHTML = "";
            itemDetailCache.clear(); // 아이템 캐시 초기화

            try {
                // 1. 캐릭터 ID 가져오기
                statusEl.textContent = "캐릭터 ID 조회 중...";
                const characterId = await getCharacterId(characterName);
                
                // 2. 모든 타임라인 데이터 가져오기 (월별)
                const allTimelineRows = await getAllTimelinePages(characterId);
                
                if (allTimelineRows.length === 0) {
                    statusEl.textContent = "조회 기간 내 아이템 획득 기록이 없습니다.";
                    searchBtn.disabled = false;
                    return;
                }

                // 3. 타임라인 처리 (오래된 순으로 정렬)
                statusEl.textContent = "타임라인 처리 중... (아이템 상세 정보 조회)";
                allTimelineRows.sort((a, b) => new Date(a.date) - new Date(b.date)); // 획득순(오름차순) 정렬

                const processedItems = [];
                const highestAcquiredRarity = {}; // Key: "세트명_부위명", Value: 등급 점수(3, 2, 1)

                let processedCount = 0;
                for (const itemDrop of allTimelineRows) {
                    processedCount++;
                    statusEl.textContent = `타임라인 처리 중... (${processedCount}/${allTimelineRows.length})`;
                    
                    const dropData = itemDrop.data;
                    const itemId = dropData.itemId;
                    const itemRarity = dropData.itemRarity;
                    const dropDate = itemDrop.date;

                    // 3-1. 아이템 상세 정보 조회
                    const details = itemDetailsCache[itemId];

                    // 3-2. 유효성 검사: 115레벨이 아니거나, 세트 아이템이 아니면 무시
                    if (!details || details.itemAvailableLevel !== 115 || !details.setItemName) {
                        continue;
                    }

                    const setItemName = details.setItemName;
                    const itemTypeDetail = details.itemTypeDetail;
                    
                    // 3-3. 유효성 로직 실행
                    const itemKey = `${setItemName}_${itemTypeDetail}`;
                    const currentRarityScore = RARITY_ORDER[itemRarity] || 0;
                    const highestRarityScore = highestAcquiredRarity[itemKey] || 0;

                    let isValid = false;
                    
                    // 🚨 희귀도별 스타일을 저장할 변수 🚨
                    let itemStyle = '';

                    // 1. 아이템 희귀도에 따른 스타일 결정
                        if (itemRarity === '레전더리') {
                            itemStyle = 'color: rgb(239, 112, 0);';
                        } else if (itemRarity === '에픽') {
                            itemStyle = 'color: rgb(239, 169, 0);';
                        } else if (itemRarity === '태초') {
                            // 그라데이션은 CSS background로 적용하는 것이 일반적이나, 
                            // 텍스트에만 적용하려면 웹킷(WebKit) 속성을 사용해야 합니다.
                            // 여기서는 텍스트 색상을 설정하고, 셀 배경에 적용하는 방식으로 처리하겠습니다.
                            itemStyle = 'color: #3057a6; font-weight: bold; background-image: linear-gradient(180deg, #55e95b, #3057a6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;';
                            // ⚠️ 주의: 웹킷(Chrome, Safari) 브라우저에서만 정상적으로 텍스트 그라데이션이 보입니다.
                        } else {
                            itemStyle = ''; // 기타 희귀도는 기본 스타일
                        }

                
                    let probabilityContent = '';
                    let styleClass = ''; // 새로 추가된 스타일 변수
                    
                    // 2. 슬롯 추적기 구조: setSlotTracker[setName] = Map<Rarity, Set<SlotName>>
                        if (!setSlotTracker[setItemName]) {
                            setSlotTracker[setItemName] = {};
                        }
                        if (!setSlotTracker[setItemName][itemRarity]) {
                            setSlotTracker[setItemName][itemRarity] = new Set();
                        }

                        // 3. 현재 희귀도의 순위 확인
                        const targetRank = RARITY_RANK[itemRarity];
                        let filledSlotCount = 0;
                        const countedSlots = new Set(); // 중복 부위 카운트를 막기 위한 Set

                        // 4. 이미 채워진 부위 카운트 (순위가 같거나 더 높은 희귀도만 카운트)
                        // '더 높은 희귀도'는 순위 값이 '더 낮거나 같은' 경우입니다.
                        for (const r in RARITY_RANK) {
                            if (RARITY_RANK[r] <= targetRank) {
                                if (setSlotTracker[setItemName][r]) {
                                    setSlotTracker[setItemName][r].forEach(slot => {
                                        // 🚨 태초 등급 아이템일 경우, 슬롯을 3개로 제한 🚨
                        if (itemRarity === '태초' && !TAECHO_SLOTS.includes(slot)) {
                            return; // 태초가 아닌 부위는 카운트하지 않음
                        }
                                        countedSlots.add(slot);
                                    });
                                }
                            }
                        }
                        // 5. 태초 아이템의 경우, 카운팅 된 부위 중 최대 3개만 유효 부위로 간주
        if (itemRarity === '태초') {
            filledSlotCount = Math.min(countedSlots.size, MAX_TAECHO_SLOTS);
        } else {
            filledSlotCount = countedSlots.size;
        }
                    
                        // 5. 확률 계산
                        if (filledSlotCount < TOTAL_SET_SLOTS) {
                            // 남은 유효 부위 개수: 11 - 현재 획득한 부위 개수
                            let remainingValidSlots = TOTAL_SET_SLOTS - filledSlotCount;
                            let probability = (remainingValidSlots / TOTAL_SET_SLOTS) * 100;
                            if (itemRarity === '태초') {
                                remainingValidSlots = MAX_TAECHO_SLOTS - filledSlotCount;
                                probability = (remainingValidSlots / MAX_TAECHO_SLOTS) * 100;
                            }

                            // 소수점 첫째 자리에서 반올림
                            const roundedProbability = Math.round(probability); 
                            probabilityContent = `${roundedProbability}%`;

                            // 🚨 확률 구간에 따른 스타일 클래스 결정 🚨
                            if (roundedProbability <= 25) {
                                styleClass = 'prob-low';
                            } else if (roundedProbability <= 50) {
                                styleClass = 'prob-mid-low';
                            } else if (roundedProbability <= 75) {
                                styleClass = 'prob-mid-high';
                            } else { // 76% ~ 100%
                                styleClass = 'prob-high';
                            }
                        } else {
                            // 이미 11부위를 다 채운 경우
                            probabilityContent = '0%';
                            styleClass = 'prob-low'; // 0%는 가장 낮은 구간으로 설정
                        }
                        
                        // 6. 슬롯 트래커 업데이트 (확률 계산 후, 현재 아이템 부위를 추가)
                    // 7. 슬롯 트래커 업데이트
        // 🚨 태초일 경우, 트래커에 추가할 때도 3개 부위만 추가하도록 제약 🚨
        if (itemRarity === '태초' && !TAECHO_SLOTS.includes(itemTypeDetail)) {
             // 태초 아이템이 아닌 부위 (예: 무기)로 잘못 들어왔다면 트래커에 추가하지 않음
        } else {
                        setSlotTracker[setItemName][itemRarity].add(itemTypeDetail);
        }
                    
                    // 현재 획득한 아이템 등급이 이전에 획득한 최고 등급보다 높아야 유효
                    if (currentRarityScore > highestRarityScore) {
                        isValid = true;
                        highestAcquiredRarity[itemKey] = currentRarityScore; // 최고 등급 갱신
                    }

                    processedItems.push({
                        date: dropDate,
                        itemName: dropData.itemName,
                        rarity: itemRarity,
                        setName: setItemName,
                        slot: itemTypeDetail,
                        isValid: isValid,
                        probabilityContent: probabilityContent,
                        styleClass: styleClass,
                        style: itemStyle
                    });
                }


                // 🚨 전역 변수에 전체 데이터 저장 🚨
            allTimelinePages = processedItems;
                filterTimeline();
                // 4. 결과 출력
                displayResults();

            } catch (error) {
                console.error(error);
                statusEl.textContent = `오류 발생: ${error.message}`;
            } finally {
                searchBtn.disabled = false;
                if (!statusEl.textContent.startsWith("오류")) {
                    statusEl.textContent = "조회 완료!";
                }
            }
        }

        // --- 유틸리티 함수 ---

        // 결과 테이블에 표시
        function displayResults() {
            const items = filteredTimelinePages;
            // 최신순(내림차순)으로 정렬하여 표시
            items.sort((a, b) => new Date(b.date) - new Date(a.date));

            if (items.length === 0) {
                resultsEl.innerHTML = '<tr><td colspan="6">표시할 115레벨 세트 아이템이 없습니다.</td></tr>';
                return;
            }

            let html = "";
            for (const item of items) {
                const validityClass = item.isValid ? 'valid-true' : 'valid-false';
                const validityText = item.isValid ? '유효' : '무효';

                html += `
                    <tr>
                        <td>${item.date}</td>
                        <td style="${item.style}">${item.itemName}</td>
                        <td style="${item.style}">${item.rarity}</td>
                        <td>${item.setName}</td>
                        <td>${item.slot}</td>
                        <td class="probability-cell ${item.styleClass}">${item.probabilityContent}</td>
                        <td class="${validityClass}">${validityText}</td>
                    </tr>
                `;
            }
            resultsEl.innerHTML = html;
        }

        // 날짜를 'YYYYMMDD' 형식의 문자열로 변환
        function formatDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}${month}${day}`;
        }

        /**
 * 체크박스 상태에 따라 타임라인 데이터를 필터링하고 노출합니다.
 */
function filterTimeline() {
    if (!allTimelinePages || allTimelinePages.length === 0) {
        return; // 데이터가 없거나 테이블이 준비되지 않았으면 종료
    }
    
    // 1. 체크된 등급(Rarities) 확인
    const checkedRarities = [];
    if (document.getElementById('filterTaecho')?.checked) checkedRarities.push('태초');
    if (document.getElementById('filterEpic')?.checked) checkedRarities.push('에픽');
    if (document.getElementById('filterLegendary')?.checked) checkedRarities.push('레전더리');
    
    // 체크된 등급이 없으면 모든 데이터를 노출하지 않습니다.
    if (checkedRarities.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center;">선택된 아이템 등급이 없습니다.</td></tr>';
        return;
    }

    // 2. 전체 데이터를 순회하며 필터링
    filteredTimelinePages = allTimelinePages.filter(row => checkedRarities.includes(row.rarity));
}

        // ------------------------------------------------------------------
// 🚨 DOM 로드 후 이벤트 리스너 연결 🚨
document.addEventListener('DOMContentLoaded', (event) => {
    const inputElement = document.getElementById('characterNameInput');
    
    // input 요소가 존재하는지 확인 후 이벤트 리스너 연결
    if (inputElement) {
        inputElement.addEventListener('keydown', handleEnterKey);
    }
});
    </script>

</body>
</html>






















