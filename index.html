<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë˜íŒŒ ì•„ì´í…œ ìœ íš¨ì„± ê²€ì‚¬ê¸°</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Malgun Gothic", "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        h1 {
            color: #1a1a1a;
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .input-area {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        #characterNameInput {
            flex-grow: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        #searchButton {
            padding: 10px 20px;
            border: none;
            background-color: #007bff;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #searchButton:hover {
            background-color: #0056b3;
        }
        #searchButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
            color: #555;
            font-weight: bold;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .results-table th, .results-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-size: 14px;
        }
        .results-table th {
            background-color: #f9f9f9;
        }
        .valid-true {
            color: #28a745;
            font-weight: bold;
        }
        .valid-false {
            color: #dc3545;
        }
        /* í™•ë¥  ì…€ ìŠ¤íƒ€ì¼ */
.probability-cell {
    font-weight: bold;
    text-align: center !important;
    padding: 8px;
    border-radius: 4px;
}

/* 4êµ¬ê°„ ìŠ¤íƒ€ì¼ ì •ì˜ (0%~100%) */

/* êµ¬ê°„ 1: 0% ~ 25% (ê°€ì¥ ë‚®ì€ í™•ë¥ , ë‚˜ì¨ - ë¹¨ê°•/ì£¼í™©) */
.prob-low {
    background-color: #ff9999; /* ë°ì€ ë¹¨ê°• */
    color: #800000;
}

/* êµ¬ê°„ 2: 26% ~ 50% (ë³´í†µ - ë…¸ë‘) */
.prob-mid-low {
    background-color: #ffda6a; /* ë…¸ë€ìƒ‰ */
    color: #995c00;
}

/* êµ¬ê°„ 3: 51% ~ 75% (ì¢‹ìŒ - ì—°ë‘) */
.prob-mid-high {
    background-color: #b3e6b3; /* ë°ì€ ë…¹ìƒ‰ */
    color: #004d00;
}

/* êµ¬ê°„ 4: 76% ~ 100% (ê°€ì¥ ë†’ì€ í™•ë¥ , ë§¤ìš° ì¢‹ìŒ - íŒŒë‘/ì´ˆë¡) */
.prob-high {
    background-color: #8cd98c; /* ì§„í•œ ë…¹ìƒ‰ */
    color: #003300;
}
    </style>
</head>
<body>

    <div class="container">
        <h1>ì•„ì´í…œ íšë“ ìœ íš¨ì„± ê²€ì‚¬ê¸°</h1>
        <div class="input-area">
            <input type="text" id="characterNameInput" placeholder="ìºë¦­í„°ëª…ì„ ì…ë ¥í•˜ì„¸ìš” (ì„œë²„: ì¹´ì¸)">
            <button id="searchButton">ì¡°íšŒ</button>
        </div>
        <div id="status"></div>
        <table class="results-table">
            <thead>
                <tr>
                    <th>íšë“ ì‹œê°„</th>
                    <th>ì•„ì´í…œëª…</th>
                    <th>ë“±ê¸‰</th>
                    <th>ì„¸íŠ¸</th>
                    <th>ë¶€ìœ„</th>
                    <th>ìœ íš¨ í™•ë¥ </th>
                    <th>ìœ íš¨ ì—¬ë¶€</th>
                </tr>
            </thead>
            <tbody id="resultsContainer">
                </tbody>
        </table>
    </div>

    <script>
        // ì „ì—­ ìºì‹œ ê°ì²´: ì•„ì´í…œ IDë¥¼ í‚¤(Key)ë¡œ, ì•„ì´í…œ ìƒì„¸ ì •ë³´ë¥¼ ê°’(Value)ìœ¼ë¡œ ì €ì¥
        const itemDetailsCache = {};
        
        // ğŸš¨ ì•„ì´í…œ íšë“ ì‹œì ê¹Œì§€ì˜ ì„¸íŠ¸ ë¶€ìœ„ ì ìœ  ìƒíƒœë¥¼ ì¶”ì í•˜ëŠ” ê°ì²´
// Key: "ì„¸íŠ¸ì´ë¦„-í¬ê·€ë„" (ì˜ˆ: "ì„¸ë Œë””í”¼í‹° ì„¸íŠ¸-ì—í”½")
// Value: Set ê°ì²´ë¡œ, ì´ë¯¸ íšë“í•œ ìŠ¬ë¡¯ ë¶€ìœ„ ì´ë¦„ë“¤ì„ ì €ì¥í•©ë‹ˆë‹¤.
const setSlotTracker = {};
        
        // ì „ì²´ ì„¸íŠ¸ ë¶€ìœ„ ìˆ˜ (ë¬´ê¸° ì œì™¸ 11ê°œ)
const TOTAL_SET_SLOTS = 11; 
// ìœ íš¨ í¬ê·€ë„ ëª©ë¡
const VALID_RARITIES = ['íƒœì´ˆ', 'ì—í”½', 'ë ˆì „ë”ë¦¬'];
        
        // --- ì„¤ì • ë° ìƒìˆ˜ ---
// *** í”„ë¡ì‹œ ì„œë²„ì˜ ê¸°ë³¸ ê²½ë¡œë¥¼ ì •ì˜í•©ë‹ˆë‹¤. ***
// Vercelì— ë°°í¬ëœ ê²½ìš°, /api/proxyëŠ” api/proxy.js ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜ë¡œ ì—°ê²°ë©ë‹ˆë‹¤.
const PROXY_BASE_URL = "/api/proxy/df"; // Neople APIì˜ /df ì´ì „ ê²½ë¡œë¥¼ í”„ë¡ì‹œë¡œ ì§€ì •
        
        const SERVER_ID = "cain";
        
        // ì•„ì´í…œ ë“±ê¸‰ ìš°ì„ ìˆœìœ„ (ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ)
        const RARITY_ORDER = {
            "íƒœì´ˆ": 3,
            "ì—í”½": 2,
            "ë ˆì „ë”ë¦¬": 1
        };

        // --- DOM ìš”ì†Œ ---
        const charInput = document.getElementById('characterNameInput');
        const searchBtn = document.getElementById('searchButton');
        const statusEl = document.getElementById('status');
        const resultsEl = document.getElementById('resultsContainer');

        // --- API í˜¸ì¶œ í•¨ìˆ˜ ---

        // 1. ìºë¦­í„° ID ì¡°íšŒ
        async function getCharacterId(characterName) {
            const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters?characterName=${encodeURIComponent(characterName)}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error("ìºë¦­í„° ID ì¡°íšŒ ì‹¤íŒ¨");
            const data = await response.json();
            if (!data.rows || data.rows.length === 0) throw new Error("ìºë¦­í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return data.rows[0].characterId;
        }

        // 2. íƒ€ì„ë¼ì¸ ì¡°íšŒ (ì›”ë³„ë¡œ ë°˜ë³µ í˜¸ì¶œ)
        async function getAllTimelinePages(characterId) {
            let allTimelineRows = [];
            let currentMonthStart = new Date('2025-01-01');
            const today = new Date();

            while (currentMonthStart < today) {
                // ë‹¤ìŒ ë‹¬ 1ì¼ ê³„ì‚°
                let nextMonthStart = new Date(currentMonthStart.getFullYear(), currentMonthStart.getMonth() + 1, 1);
                if (nextMonthStart > today) {
                    nextMonthStart = today;
                }
                
                // ë‚ ì§œ í¬ë§·íŒ… (YYYYMMDD)
                const startDateStr = formatDate(currentMonthStart);
                const endDateStr = nextMonthStart === today ? formatDate(nextMonthStart) + formatToApiTime(nextMonthStart) : formatDate(nextMonthStart);

                statusEl.textContent = `${currentMonthStart.getFullYear()}ë…„ ${currentMonthStart.getMonth() + 1}ì›” íƒ€ì„ë¼ì¸ ì¡°íšŒ ì¤‘...`;
                
                const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters/${characterId}/timeline?limit=100&code=505,507,513&startDate=${startDateStr}&endDate=${endDateStr}`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.timeline && data.timeline.rows) {
                        allTimelineRows.push(...data.timeline.rows);
                    }
                } catch (e) {
                    console.error(`${startDateStr} íƒ€ì„ë¼ì¸ ì¡°íšŒ ì‹¤íŒ¨:`, e);
                    // í•œë‘ ë‹¬ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
                }

                // ë‹¤ìŒ ë‹¬ë¡œ ì´ë™
                currentMonthStart = nextMonthStart;
            }

            const allItemIds = [];
    allTimelineRows.forEach(row => {
            if (row.data && row.data.itemId) {
                // itemIdê°€ ì‰¼í‘œë¡œ ë¶„ë¦¬ë˜ì–´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëª¨ë‘ ì¶”ì¶œ
                const ids = row.data.itemId.split(',').map(id => id.trim()).filter(id => id.length > 0);
                allItemIds.push(...ids);
            }
        });

    // ìˆ˜ì§‘ëœ ëª¨ë“  ì•„ì´í…œ IDì— ëŒ€í•´ ë‹¤ì¤‘ ì¡°íšŒ í•¨ìˆ˜ í˜¸ì¶œ
    await getTimelineItemDetails(allItemIds);
            return allTimelineRows;
        }

// âš ï¸ ì¶”ê°€: APIê°€ ìš”êµ¬í•˜ëŠ” hhmm í˜•ì‹ìœ¼ë¡œ ì‹œê°„ì„ í¬ë§·í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
function formatToApiTime(date) {
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `T${hh}${mm}`;
}

        // ê¸°ì¡´: getItemDetails(itemId)ë¥¼ ëŒ€ì²´í•˜ëŠ” í•¨ìˆ˜
// íƒ€ì„ë¼ì¸ì—ì„œ í•„ìš”í•œ ëª¨ë“  ì•„ì´í…œ ID ëª©ë¡ì„ ë°›ì•„ ì •ë³´ë¥¼ ì¡°íšŒí•˜ê³  ìºì‹œì— ì €ì¥í•©ë‹ˆë‹¤.
async function getTimelineItemDetails(allItemIds) {
    const uniqueItemIds = Array.from(new Set(allItemIds));
    const itemIdsToFetch = [];
    
    // 1. ìºì‹œ í™•ì¸ ë° ì¡°íšŒí•  ëª©ë¡ ë¶„ë¥˜
    for (const itemId of uniqueItemIds) {
        if (!itemDetailsCache[itemId]) {
            itemIdsToFetch.push(itemId); // ìºì‹œì— ì—†ëŠ” ì•„ì´í…œë§Œ ì¡°íšŒ ëª©ë¡ì— ì¶”ê°€
        }
    }

    if (itemIdsToFetch.length === 0) {
        console.log("[Multi-Fetch] All items found in cache.");
        return; // ì¡°íšŒí•  ì•„ì´í…œì´ ì—†ìœ¼ë©´ ì¢…ë£Œ
    }

    console.log(`[Multi-Fetch] Need to fetch ${itemIdsToFetch.length} items.`);

    // 2. ì•„ì´í…œ IDë¥¼ ìµœëŒ€ 15ê°œì”© ë¬¶ì–´ API í˜¸ì¶œ
    const CHUNK_SIZE = 15;
    const fetchPromises = [];

    for (let i = 0; i < itemIdsToFetch.length; i += CHUNK_SIZE) {
        const chunk = itemIdsToFetch.slice(i, i + CHUNK_SIZE);
        const itemIdsParam = chunk.join(','); // ì•„ì´í…œ IDë“¤ì„ ì½¤ë§ˆë¡œ ì—°ê²°

        // ë‹¤ì¤‘ ì¡°íšŒ API URL
        const url = `${PROXY_BASE_URL}/multi/items?itemIds=${encodeURIComponent(itemIdsParam)}`;
        
        // í”„ë¡ì‹œ ì„œë²„ì— ìš”ì²­ì„ ë³´ë‚´ê³  Promiseë¥¼ ë°°ì—´ì— ì €ì¥
        fetchPromises.push(
            fetch(url)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`ë‹¤ì¤‘ ì•„ì´í…œ ì¡°íšŒ ì‹¤íŒ¨: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // 3. ì‘ë‹µ ë°ì´í„°ë¥¼ íŒŒì‹±í•˜ì—¬ ìºì‹œì— ì €ì¥
                if (data.rows) {
                    for (const itemData of data.rows) {
                        const itemId = itemData.itemId;
                        itemDetailsCache[itemId] = itemData; // ìºì‹œ ì—…ë°ì´íŠ¸
                    }
                }
            })
            .catch(error => {
                console.error(`ì•„ì´í…œ ë¬¶ìŒ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error.message}`);
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ í•´ë‹¹ ì•„ì´í…œë“¤ì˜ ìºì‹œ í•­ëª©ì€ undefinedë¡œ ë‚¨ìŠµë‹ˆë‹¤.
            })
        );
    }

    // 4. ëª¨ë“  API í˜¸ì¶œì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.
    await Promise.all(fetchPromises);
}

        // 3. ì•„ì´í…œ ìƒì„¸ ì •ë³´ ì¡°íšŒ (ìºì‹œ ì‚¬ìš©)
        const itemDetailCache = new Map();
        async function getItemDetails(itemId) {
            if (itemDetailCache.has(itemId)) {
                return itemDetailCache.get(itemId);
            }
            
            const url = `${PROXY_BASE_URL}/items/${itemId}`;
            try {
                const response = await fetch(url);
                if (!response.ok) return null; // ì¡°íšŒ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
                const data = await response.json();
                itemDetailCache.set(itemId, data); // ìºì‹œì— ì €ì¥
                return data;
            } catch (e) {
                console.error(`ì•„ì´í…œ(${itemId}) ìƒì„¸ ì¡°íšŒ ì‹¤íŒ¨:`, e);
                return null;
            }
        }

        // --- ë©”ì¸ ë¡œì§ ---
        searchBtn.addEventListener('click', async () => {
            const characterName = charInput.value.trim();
            if (!characterName) {
                alert("ìºë¦­í„°ëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                return;
            }

            // ì´ˆê¸°í™”
            searchBtn.disabled = true;
            statusEl.textContent = "ì¡°íšŒë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...";
            resultsEl.innerHTML = "";
            itemDetailCache.clear(); // ì•„ì´í…œ ìºì‹œ ì´ˆê¸°í™”

            try {
                // 1. ìºë¦­í„° ID ê°€ì ¸ì˜¤ê¸°
                statusEl.textContent = "ìºë¦­í„° ID ì¡°íšŒ ì¤‘...";
                const characterId = await getCharacterId(characterName);
                
                // 2. ëª¨ë“  íƒ€ì„ë¼ì¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ì›”ë³„)
                const allTimelineRows = await getAllTimelinePages(characterId);
                
                if (allTimelineRows.length === 0) {
                    statusEl.textContent = "ì¡°íšŒ ê¸°ê°„ ë‚´ ì•„ì´í…œ íšë“ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.";
                    searchBtn.disabled = false;
                    return;
                }

                // 3. íƒ€ì„ë¼ì¸ ì²˜ë¦¬ (ì˜¤ë˜ëœ ìˆœìœ¼ë¡œ ì •ë ¬)
                statusEl.textContent = "íƒ€ì„ë¼ì¸ ì²˜ë¦¬ ì¤‘... (ì•„ì´í…œ ìƒì„¸ ì •ë³´ ì¡°íšŒ)";
                allTimelineRows.sort((a, b) => new Date(a.date) - new Date(b.date)); // íšë“ìˆœ(ì˜¤ë¦„ì°¨ìˆœ) ì •ë ¬

                const processedItems = [];
                const highestAcquiredRarity = {}; // Key: "ì„¸íŠ¸ëª…_ë¶€ìœ„ëª…", Value: ë“±ê¸‰ ì ìˆ˜(3, 2, 1)

                let processedCount = 0;
                for (const itemDrop of allTimelineRows) {
                    processedCount++;
                    statusEl.textContent = `íƒ€ì„ë¼ì¸ ì²˜ë¦¬ ì¤‘... (${processedCount}/${allTimelineRows.length})`;
                    
                    const dropData = itemDrop.data;
                    const itemId = dropData.itemId;
                    const itemRarity = dropData.itemRarity;
                    const dropDate = itemDrop.date;

                    // 3-1. ì•„ì´í…œ ìƒì„¸ ì •ë³´ ì¡°íšŒ
                    const details = itemDetailsCache[itemId];

                    // 3-2. ìœ íš¨ì„± ê²€ì‚¬: 115ë ˆë²¨ì´ ì•„ë‹ˆê±°ë‚˜, ì„¸íŠ¸ ì•„ì´í…œì´ ì•„ë‹ˆë©´ ë¬´ì‹œ
                    if (!details || details.itemAvailableLevel !== 115 || !details.setItemName) {
                        continue;
                    }

                    const setItemName = details.setItemName;
                    const itemTypeDetail = details.itemTypeDetail;
                    
                    // 3-3. ìœ íš¨ì„± ë¡œì§ ì‹¤í–‰
                    const itemKey = `${setItemName}_${itemTypeDetail}`;
                    const currentRarityScore = RARITY_ORDER[itemRarity] || 0;
                    const highestRarityScore = highestAcquiredRarity[itemKey] || 0;

                    let isValid = false;

                
                    let probabilityContent = '';
                    let styleClass = ''; // ìƒˆë¡œ ì¶”ê°€ëœ ìŠ¤íƒ€ì¼ ë³€ìˆ˜
                    
            // 2. ì¶”ì  í‚¤ ì •ì˜ (ì„¸íŠ¸ ì´ë¦„ê³¼ í¬ê·€ë„)
                        // íƒœì´ˆ/ì—í”½ì€ ì„¸íŠ¸ ì•„ì´í…œìœ¼ë¡œ ê°„ì£¼í•˜ì—¬ í•˜ë‚˜ì˜ ì¹´í…Œê³ ë¦¬ë¡œ ë¬¶ìŒ.
                        // ë ˆì „ë”ë¦¬ëŠ” ì„¸íŠ¸ëª…ì´ ìˆì–´ë„ 11ê°œ ìŠ¬ë¡¯ì˜ ìœ íš¨ ì—¬ë¶€ë§Œ ë”°ì§€ëŠ” ë‹¨ìˆœí•œ í™•ë¥ ë¡œ ê°„ì£¼
                        let trackerKey = '';
                        if (itemRarity === 'ë ˆì „ë”ë¦¬') {
                            // ë ˆì „ë”ë¦¬ëŠ” ë³„ë„ì˜ íŠ¸ë˜í‚¹ ì—†ì´ í•­ìƒ 11/11ë¡œ ì²˜ë¦¬í•˜ê±°ë‚˜,
                            // (ìš”ì²­ì— ë”°ë¼) ì „ì²´ ë¶€ìœ„ì—ì„œ ìœ íš¨ í™•ë¥ ë§Œ ë‚¨ì€ ê²ƒìœ¼ë¡œ ì²˜ë¦¬
                            trackerKey = `ë ˆì „ë”ë¦¬-${setName || 'ë‹¨ì¼'}`;
                        } else { // íƒœì´ˆ, ì—í”½ (ì„¸íŠ¸í…œ)
                            trackerKey = `${setName}-${itemRarity}`;
                        }
                        
                        // 3. ìŠ¬ë¡¯ íŠ¸ë˜ì»¤ ì´ˆê¸°í™”
                        if (!setSlotTracker[trackerKey]) {
                            setSlotTracker[trackerKey] = new Set();
                        }
                        
                        // 4. í˜„ì¬ íšë“í•œ ë¶€ìœ„ ê°œìˆ˜ í™•ì¸
                        const currentCount = setSlotTracker[trackerKey].size;
                        
                        // 5. í™•ë¥  ê³„ì‚°
                        if (currentCount < TOTAL_SET_SLOTS) {
                            // ë‚¨ì€ ìœ íš¨ ë¶€ìœ„ ê°œìˆ˜: 11 - í˜„ì¬ íšë“í•œ ë¶€ìœ„ ê°œìˆ˜
                            const remainingValidSlots = TOTAL_SET_SLOTS - currentCount;
                            const probability = (remainingValidSlots / TOTAL_SET_SLOTS) * 100;

                            // ì†Œìˆ˜ì  ì²«ì§¸ ìë¦¬ì—ì„œ ë°˜ì˜¬ë¦¼
                            const roundedProbability = Math.round(probability); 
                            probabilityContent = `${roundedProbability}%`;

                            // ğŸš¨ í™•ë¥  êµ¬ê°„ì— ë”°ë¥¸ ìŠ¤íƒ€ì¼ í´ë˜ìŠ¤ ê²°ì • ğŸš¨
                            if (roundedProbability <= 25) {
                                styleClass = 'prob-low';
                            } else if (roundedProbability <= 50) {
                                styleClass = 'prob-mid-low';
                            } else if (roundedProbability <= 75) {
                                styleClass = 'prob-mid-high';
                            } else { // 76% ~ 100%
                                styleClass = 'prob-high';
                            }
                        } else {
                            // ì´ë¯¸ 11ë¶€ìœ„ë¥¼ ë‹¤ ì±„ìš´ ê²½ìš°
                            probabilityContent = '0%';
                            styleClass = 'prob-low'; // 0%ëŠ” ê°€ì¥ ë‚®ì€ êµ¬ê°„ìœ¼ë¡œ ì„¤ì •
                        }
                        
                        // 6. ìŠ¬ë¡¯ íŠ¸ë˜ì»¤ ì—…ë°ì´íŠ¸ (ì´ë¯¸ íšë“í•œ ê²ƒìœ¼ë¡œ í‘œì‹œ)
                        // ì£¼ì˜: ì´ ì•„ì´í…œì˜ í™•ë¥ ì„ ê³„ì‚°í•œ í›„, ë‹¤ìŒ ì•„ì´í…œ ê³„ì‚°ì„ ìœ„í•´ í•´ë‹¹ ë¶€ìœ„ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
                        // (ì´ ë¶€ìœ„ëŠ” ì´ë¯¸ íƒ€ì„ë¼ì¸ì— ë–´ìœ¼ë¯€ë¡œ ë‹¤ìŒ íšë“ í™•ë¥  ê³„ì‚° ì‹œ ì œì™¸ë˜ì–´ì•¼ í•¨)
                        setSlotTracker[trackerKey].add(slotName);
                    
                    // í˜„ì¬ íšë“í•œ ì•„ì´í…œ ë“±ê¸‰ì´ ì´ì „ì— íšë“í•œ ìµœê³  ë“±ê¸‰ë³´ë‹¤ ë†’ì•„ì•¼ ìœ íš¨
                    if (currentRarityScore > highestRarityScore) {
                        isValid = true;
                        highestAcquiredRarity[itemKey] = currentRarityScore; // ìµœê³  ë“±ê¸‰ ê°±ì‹ 
                    }

                    processedItems.push({
                        date: dropDate,
                        itemName: dropData.itemName,
                        rarity: itemRarity,
                        setName: setItemName,
                        slot: itemTypeDetail,
                        isValid: isValid,
                        probabilityContent: probabilityContent,
                        styleClass: styleClass
                    });
                }

                // 4. ê²°ê³¼ ì¶œë ¥
                displayResults(processedItems);

            } catch (error) {
                console.error(error);
                statusEl.textContent = `ì˜¤ë¥˜ ë°œìƒ: ${error.message}`;
            } finally {
                searchBtn.disabled = false;
                if (!statusEl.textContent.startsWith("ì˜¤ë¥˜")) {
                    statusEl.textContent = "ì¡°íšŒ ì™„ë£Œ!";
                }
            }
        });

        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---

        // ê²°ê³¼ í…Œì´ë¸”ì— í‘œì‹œ
        function displayResults(items) {
            // ìµœì‹ ìˆœ(ë‚´ë¦¼ì°¨ìˆœ)ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ í‘œì‹œ
            items.sort((a, b) => new Date(b.date) - new Date(a.date));

            if (items.length === 0) {
                resultsEl.innerHTML = '<tr><td colspan="6">í‘œì‹œí•  115ë ˆë²¨ ì„¸íŠ¸ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
                return;
            }

            let html = "";
            for (const item of items) {
                const validityClass = item.isValid ? 'valid-true' : 'valid-false';
                const validityText = item.isValid ? 'ìœ íš¨' : 'ë¬´íš¨';

                html += `
                    <tr>
                        <td>${item.date}</td>
                        <td>${item.itemName}</td>
                        <td>${item.rarity}</td>
                        <td>${item.setName}</td>
                        <td>${item.slot}</td>
                        <td class="probability-cell ${item.styleClass}">${item.probabilityContent}</td>
                        <td class="${validityClass}">${validityText}</td>
                    </tr>
                `;
            }
            resultsEl.innerHTML = html;
        }

        // ë‚ ì§œë¥¼ 'YYYYMMDD' í˜•ì‹ì˜ ë¬¸ìì—´ë¡œ ë³€í™˜
        function formatDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}${month}${day}`;
        }
    </script>

</body>
</html>








