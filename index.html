<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>던파 아이템 유효성 검사기</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Malgun Gothic", "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        h1 {
            color: #1a1a1a;
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .input-area {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        #characterNameInput {
            flex-grow: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        #searchButton {
            padding: 10px 20px;
            border: none;
            background-color: #007bff;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #searchButton:hover {
            background-color: #0056b3;
        }
        #searchButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
            color: #555;
            font-weight: bold;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .results-table th, .results-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-size: 14px;
        }
        .results-table th {
            background-color: #f9f9f9;
        }
        .valid-true {
            color: #28a745;
            font-weight: bold;
        }
        .valid-false {
            color: #dc3545;
        }
        /* 확률 셀 스타일 */
.probability-cell {
    font-weight: bold;
    text-align: center !important;
    padding: 8px;
    border-radius: 4px;
}

/* 4구간 스타일 정의 (0%~100%) */

/* 구간 1: 0% ~ 25% (가장 낮은 확률, 나쁨 - 빨강/주황) */
.prob-low {
    background-color: #ff9999; /* 밝은 빨강 */
    color: #800000;
}

/* 구간 2: 26% ~ 50% (보통 - 노랑) */
.prob-mid-low {
    background-color: #ffda6a; /* 노란색 */
    color: #995c00;
}

/* 구간 3: 51% ~ 75% (좋음 - 연두) */
.prob-mid-high {
    background-color: #b3e6b3; /* 밝은 녹색 */
    color: #004d00;
}

/* 구간 4: 76% ~ 100% (가장 높은 확률, 매우 좋음 - 파랑/초록) */
.prob-high {
    background-color: #8cd98c; /* 진한 녹색 */
    color: #003300;
}
    </style>
</head>
<body>

    <div class="container">
        <h1>아이템 획득 유효성 검사기</h1>
        <div class="input-area">
            <input type="text" id="characterNameInput" placeholder="캐릭터명을 입력하세요 (서버: 카인)">
            <button id="searchButton">조회</button>
        </div>
        <div id="status"></div>
        <table class="results-table">
            <thead>
                <tr>
                    <th>획득 시간</th>
                    <th>아이템명</th>
                    <th>등급</th>
                    <th>세트</th>
                    <th>부위</th>
                    <th>유효 확률</th>
                    <th>유효 여부</th>
                </tr>
            </thead>
            <tbody id="resultsContainer">
                </tbody>
        </table>
    </div>

    <script>
        // 전역 캐시 객체: 아이템 ID를 키(Key)로, 아이템 상세 정보를 값(Value)으로 저장
        const itemDetailsCache = {};
        
        // 🚨 아이템 획득 시점까지의 세트 부위 점유 상태를 추적하는 객체
// Key: "세트이름-희귀도" (예: "세렌디피티 세트-에픽")
// Value: Set 객체로, 이미 획득한 슬롯 부위 이름들을 저장합니다.
const setSlotTracker = {};
        
        // 전체 세트 부위 수 (무기 제외 11개)
const TOTAL_SET_SLOTS = 11; 
// 유효 희귀도 목록
const VALID_RARITIES = ['태초', '에픽', '레전더리'];
        
        // --- 설정 및 상수 ---
// *** 프록시 서버의 기본 경로를 정의합니다. ***
// Vercel에 배포된 경우, /api/proxy는 api/proxy.js 서버리스 함수로 연결됩니다.
const PROXY_BASE_URL = "/api/proxy/df"; // Neople API의 /df 이전 경로를 프록시로 지정
        
        const SERVER_ID = "cain";
        
        // 아이템 등급 우선순위 (높을수록 좋음)
        const RARITY_ORDER = {
            "태초": 3,
            "에픽": 2,
            "레전더리": 1
        };

        // --- DOM 요소 ---
        const charInput = document.getElementById('characterNameInput');
        const searchBtn = document.getElementById('searchButton');
        const statusEl = document.getElementById('status');
        const resultsEl = document.getElementById('resultsContainer');

        // --- API 호출 함수 ---

        // 1. 캐릭터 ID 조회
        async function getCharacterId(characterName) {
            const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters?characterName=${encodeURIComponent(characterName)}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error("캐릭터 ID 조회 실패");
            const data = await response.json();
            if (!data.rows || data.rows.length === 0) throw new Error("캐릭터를 찾을 수 없습니다.");
            return data.rows[0].characterId;
        }

        // 2. 타임라인 조회 (월별로 반복 호출)
        async function getAllTimelinePages(characterId) {
            let allTimelineRows = [];
            let currentMonthStart = new Date('2025-01-01');
            const today = new Date();

            while (currentMonthStart < today) {
                // 다음 달 1일 계산
                let nextMonthStart = new Date(currentMonthStart.getFullYear(), currentMonthStart.getMonth() + 1, 1);
                if (nextMonthStart > today) {
                    nextMonthStart = today;
                }
                
                // 날짜 포맷팅 (YYYYMMDD)
                const startDateStr = formatDate(currentMonthStart);
                const endDateStr = nextMonthStart === today ? formatDate(nextMonthStart) + formatToApiTime(nextMonthStart) : formatDate(nextMonthStart);

                statusEl.textContent = `${currentMonthStart.getFullYear()}년 ${currentMonthStart.getMonth() + 1}월 타임라인 조회 중...`;
                
                const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters/${characterId}/timeline?limit=100&code=505,507,513&startDate=${startDateStr}&endDate=${endDateStr}`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.timeline && data.timeline.rows) {
                        allTimelineRows.push(...data.timeline.rows);
                    }
                } catch (e) {
                    console.error(`${startDateStr} 타임라인 조회 실패:`, e);
                    // 한두 달 실패해도 계속 진행
                }

                // 다음 달로 이동
                currentMonthStart = nextMonthStart;
            }

            const allItemIds = [];
    allTimelineRows.forEach(row => {
            if (row.data && row.data.itemId) {
                // itemId가 쉼표로 분리되어 있을 수 있으므로 모두 추출
                const ids = row.data.itemId.split(',').map(id => id.trim()).filter(id => id.length > 0);
                allItemIds.push(...ids);
            }
        });

    // 수집된 모든 아이템 ID에 대해 다중 조회 함수 호출
    await getTimelineItemDetails(allItemIds);
            return allTimelineRows;
        }

// ⚠️ 추가: API가 요구하는 hhmm 형식으로 시간을 포맷하는 헬퍼 함수
function formatToApiTime(date) {
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `T${hh}${mm}`;
}

        // 기존: getItemDetails(itemId)를 대체하는 함수
// 타임라인에서 필요한 모든 아이템 ID 목록을 받아 정보를 조회하고 캐시에 저장합니다.
async function getTimelineItemDetails(allItemIds) {
    const uniqueItemIds = Array.from(new Set(allItemIds));
    const itemIdsToFetch = [];
    
    // 1. 캐시 확인 및 조회할 목록 분류
    for (const itemId of uniqueItemIds) {
        if (!itemDetailsCache[itemId]) {
            itemIdsToFetch.push(itemId); // 캐시에 없는 아이템만 조회 목록에 추가
        }
    }

    if (itemIdsToFetch.length === 0) {
        console.log("[Multi-Fetch] All items found in cache.");
        return; // 조회할 아이템이 없으면 종료
    }

    console.log(`[Multi-Fetch] Need to fetch ${itemIdsToFetch.length} items.`);

    // 2. 아이템 ID를 최대 15개씩 묶어 API 호출
    const CHUNK_SIZE = 15;
    const fetchPromises = [];

    for (let i = 0; i < itemIdsToFetch.length; i += CHUNK_SIZE) {
        const chunk = itemIdsToFetch.slice(i, i + CHUNK_SIZE);
        const itemIdsParam = chunk.join(','); // 아이템 ID들을 콤마로 연결

        // 다중 조회 API URL
        const url = `${PROXY_BASE_URL}/multi/items?itemIds=${encodeURIComponent(itemIdsParam)}`;
        
        // 프록시 서버에 요청을 보내고 Promise를 배열에 저장
        fetchPromises.push(
            fetch(url)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`다중 아이템 조회 실패: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // 3. 응답 데이터를 파싱하여 캐시에 저장
                if (data.rows) {
                    for (const itemData of data.rows) {
                        const itemId = itemData.itemId;
                        itemDetailsCache[itemId] = itemData; // 캐시 업데이트
                    }
                }
            })
            .catch(error => {
                console.error(`아이템 묶음 조회 중 오류 발생: ${error.message}`);
                // 오류 발생 시 해당 아이템들의 캐시 항목은 undefined로 남습니다.
            })
        );
    }

    // 4. 모든 API 호출이 완료될 때까지 기다립니다.
    await Promise.all(fetchPromises);
}

        // 3. 아이템 상세 정보 조회 (캐시 사용)
        const itemDetailCache = new Map();
        async function getItemDetails(itemId) {
            if (itemDetailCache.has(itemId)) {
                return itemDetailCache.get(itemId);
            }
            
            const url = `${PROXY_BASE_URL}/items/${itemId}`;
            try {
                const response = await fetch(url);
                if (!response.ok) return null; // 조회 실패 시 null 반환
                const data = await response.json();
                itemDetailCache.set(itemId, data); // 캐시에 저장
                return data;
            } catch (e) {
                console.error(`아이템(${itemId}) 상세 조회 실패:`, e);
                return null;
            }
        }

        // --- 메인 로직 ---
        searchBtn.addEventListener('click', async () => {
            const characterName = charInput.value.trim();
            if (!characterName) {
                alert("캐릭터명을 입력해주세요.");
                return;
            }

            // 초기화
            searchBtn.disabled = true;
            statusEl.textContent = "조회를 시작합니다...";
            resultsEl.innerHTML = "";
            itemDetailCache.clear(); // 아이템 캐시 초기화

            try {
                // 1. 캐릭터 ID 가져오기
                statusEl.textContent = "캐릭터 ID 조회 중...";
                const characterId = await getCharacterId(characterName);
                
                // 2. 모든 타임라인 데이터 가져오기 (월별)
                const allTimelineRows = await getAllTimelinePages(characterId);
                
                if (allTimelineRows.length === 0) {
                    statusEl.textContent = "조회 기간 내 아이템 획득 기록이 없습니다.";
                    searchBtn.disabled = false;
                    return;
                }

                // 3. 타임라인 처리 (오래된 순으로 정렬)
                statusEl.textContent = "타임라인 처리 중... (아이템 상세 정보 조회)";
                allTimelineRows.sort((a, b) => new Date(a.date) - new Date(b.date)); // 획득순(오름차순) 정렬

                const processedItems = [];
                const highestAcquiredRarity = {}; // Key: "세트명_부위명", Value: 등급 점수(3, 2, 1)

                let processedCount = 0;
                for (const itemDrop of allTimelineRows) {
                    processedCount++;
                    statusEl.textContent = `타임라인 처리 중... (${processedCount}/${allTimelineRows.length})`;
                    
                    const dropData = itemDrop.data;
                    const itemId = dropData.itemId;
                    const itemRarity = dropData.itemRarity;
                    const dropDate = itemDrop.date;

                    // 3-1. 아이템 상세 정보 조회
                    const details = itemDetailsCache[itemId];

                    // 3-2. 유효성 검사: 115레벨이 아니거나, 세트 아이템이 아니면 무시
                    if (!details || details.itemAvailableLevel !== 115 || !details.setItemName) {
                        continue;
                    }

                    const setItemName = details.setItemName;
                    const itemTypeDetail = details.itemTypeDetail;
                    
                    // 3-3. 유효성 로직 실행
                    const itemKey = `${setItemName}_${itemTypeDetail}`;
                    const currentRarityScore = RARITY_ORDER[itemRarity] || 0;
                    const highestRarityScore = highestAcquiredRarity[itemKey] || 0;

                    let isValid = false;

                
                    let probabilityContent = '';
                    let styleClass = ''; // 새로 추가된 스타일 변수
                    
            // 2. 추적 키 정의 (세트 이름과 희귀도)
                        // 태초/에픽은 세트 아이템으로 간주하여 하나의 카테고리로 묶음.
                        // 레전더리는 세트명이 있어도 11개 슬롯의 유효 여부만 따지는 단순한 확률로 간주
                        let trackerKey = '';
                        if (itemRarity === '레전더리') {
                            // 레전더리는 별도의 트래킹 없이 항상 11/11로 처리하거나,
                            // (요청에 따라) 전체 부위에서 유효 확률만 남은 것으로 처리
                            trackerKey = `레전더리-${setName || '단일'}`;
                        } else { // 태초, 에픽 (세트템)
                            trackerKey = `${setName}-${itemRarity}`;
                        }
                        
                        // 3. 슬롯 트래커 초기화
                        if (!setSlotTracker[trackerKey]) {
                            setSlotTracker[trackerKey] = new Set();
                        }
                        
                        // 4. 현재 획득한 부위 개수 확인
                        const currentCount = setSlotTracker[trackerKey].size;
                        
                        // 5. 확률 계산
                        if (currentCount < TOTAL_SET_SLOTS) {
                            // 남은 유효 부위 개수: 11 - 현재 획득한 부위 개수
                            const remainingValidSlots = TOTAL_SET_SLOTS - currentCount;
                            const probability = (remainingValidSlots / TOTAL_SET_SLOTS) * 100;

                            // 소수점 첫째 자리에서 반올림
                            const roundedProbability = Math.round(probability); 
                            probabilityContent = `${roundedProbability}%`;

                            // 🚨 확률 구간에 따른 스타일 클래스 결정 🚨
                            if (roundedProbability <= 25) {
                                styleClass = 'prob-low';
                            } else if (roundedProbability <= 50) {
                                styleClass = 'prob-mid-low';
                            } else if (roundedProbability <= 75) {
                                styleClass = 'prob-mid-high';
                            } else { // 76% ~ 100%
                                styleClass = 'prob-high';
                            }
                        } else {
                            // 이미 11부위를 다 채운 경우
                            probabilityContent = '0%';
                            styleClass = 'prob-low'; // 0%는 가장 낮은 구간으로 설정
                        }
                        
                        // 6. 슬롯 트래커 업데이트 (이미 획득한 것으로 표시)
                        // 주의: 이 아이템의 확률을 계산한 후, 다음 아이템 계산을 위해 해당 부위를 추가합니다.
                        // (이 부위는 이미 타임라인에 떴으므로 다음 획득 확률 계산 시 제외되어야 함)
                        setSlotTracker[trackerKey].add(slotName);
                    
                    // 현재 획득한 아이템 등급이 이전에 획득한 최고 등급보다 높아야 유효
                    if (currentRarityScore > highestRarityScore) {
                        isValid = true;
                        highestAcquiredRarity[itemKey] = currentRarityScore; // 최고 등급 갱신
                    }

                    processedItems.push({
                        date: dropDate,
                        itemName: dropData.itemName,
                        rarity: itemRarity,
                        setName: setItemName,
                        slot: itemTypeDetail,
                        isValid: isValid,
                        probabilityContent: probabilityContent,
                        styleClass: styleClass
                    });
                }

                // 4. 결과 출력
                displayResults(processedItems);

            } catch (error) {
                console.error(error);
                statusEl.textContent = `오류 발생: ${error.message}`;
            } finally {
                searchBtn.disabled = false;
                if (!statusEl.textContent.startsWith("오류")) {
                    statusEl.textContent = "조회 완료!";
                }
            }
        });

        // --- 유틸리티 함수 ---

        // 결과 테이블에 표시
        function displayResults(items) {
            // 최신순(내림차순)으로 정렬하여 표시
            items.sort((a, b) => new Date(b.date) - new Date(a.date));

            if (items.length === 0) {
                resultsEl.innerHTML = '<tr><td colspan="6">표시할 115레벨 세트 아이템이 없습니다.</td></tr>';
                return;
            }

            let html = "";
            for (const item of items) {
                const validityClass = item.isValid ? 'valid-true' : 'valid-false';
                const validityText = item.isValid ? '유효' : '무효';

                html += `
                    <tr>
                        <td>${item.date}</td>
                        <td>${item.itemName}</td>
                        <td>${item.rarity}</td>
                        <td>${item.setName}</td>
                        <td>${item.slot}</td>
                        <td class="probability-cell ${item.styleClass}">${item.probabilityContent}</td>
                        <td class="${validityClass}">${validityText}</td>
                    </tr>
                `;
            }
            resultsEl.innerHTML = html;
        }

        // 날짜를 'YYYYMMDD' 형식의 문자열로 변환
        function formatDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}${month}${day}`;
        }
    </script>

</body>
</html>








