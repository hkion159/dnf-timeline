<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>던파 득템 유효성 검사기</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Malgun Gothic", "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
        }

        .container {
            /* max-width: 900px; */
            margin: 0 auto;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        h1 {
            color: #1a1a1a;
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .input-area {
            display: flex;
            gap: 10px;
            margin: 10px auto;
            max-width: 600px;
        }

        #characterNameInput {
            flex-grow: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        #searchButton {
            padding: 10px 20px;
            border: none;
            background-color: #007bff;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #searchButton:hover {
            background-color: #0056b3;
        }

        #searchButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
            color: #555;
            font-weight: bold;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .results-table th,
        .results-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-size: 14px;
        }

        .results-table th {
            background-color: #f9f9f9;
        }

        /* 테이블 행 (<tr>)에 마우스를 올렸을 때 스타일 */
        .results-table tr:hover {
            /* 배경색을 살짝 밝거나 어둡게 변경 */
            background-color: #f5f5f5;

            /* 선택 사항: 텍스트 색상을 대비되게 변경할 수도 있습니다. */
            /* color: #111; */
        }

        .valid-true {
            color: #28a745;
            font-weight: bold;
        }

        .valid-false {
            color: #dc3545;
        }

        /* 확률 셀 스타일 */
        .probability-cell {
            font-weight: bold;
            text-align: center !important;
            padding: 8px;
            border-radius: 4px;
        }

        /* 4구간 스타일 정의 (0%~100%) */

        /* 구간 1: 0% ~ 25% (가장 낮은 확률, 나쁨 - 빨강/주황) */
        .prob-low {
            background-color: #ff9999;
            /* 밝은 빨강 */
            color: #800000;
        }

        /* 구간 2: 26% ~ 50% (보통 - 노랑) */
        .prob-mid-low {
            background-color: #ffda6a;
            /* 노란색 */
            color: #995c00;
        }

        /* 구간 3: 51% ~ 75% (좋음 - 연두) */
        .prob-mid-high {
            background-color: #b3e6b3;
            /* 밝은 녹색 */
            color: #004d00;
        }

        /* 구간 4: 76% ~ 100% (가장 높은 확률, 매우 좋음 - 파랑/초록) */
        .prob-high {
            background-color: #8cd98c;
            /* 진한 녹색 */
            color: #003300;
        }

        /* 유효 확률은 낮았는데 성공한 경우 (운이 좋음 - 녹색 강조) */
        .result-success-low-prob {
            font-weight: bold;
            background-color: #d4edda;
            /* 밝은 초록색 배경 */
            color: #155724;
            /* 짙은 초록색 텍스트 */
            border: 1px solid #c3e6cb;
        }

        /* 유효 확률은 높았는데 실패한 경우 (운이 나쁨 - 빨간색 강조) */
        .result-fail-high-prob {
            font-weight: bold;
            background-color: #f8d7da;
            /* 밝은 빨간색 배경 */
            color: #721c24;
            /* 짙은 빨간색 텍스트 */
            border: 1px solid #f5c6cb;
        }

        /* 일반적인 성공/실패 표시 (경고가 필요 없는 경우) */
        .result-normal {
            font-weight: normal;
            background-color: transparent;
            color: inherit;
        }

        /* 장착 중인 세트 아이템 행 강조 스타일 */
        .highlight-set {
            background-color: #fffacd;
            /* 연한 노란색 */
            font-weight: bold;
        }

        /* 1. 컨테이너 설정: 가로 나열 및 자동 줄 바꿈 (이전과 동일) */
        .search-history-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 0;
        }

        /* 2. 개별 닉네임 태그 스타일 (수정): 작은 크기, 세로 고정 */
        .nickname-tag {
            display: inline-flex;
            height: 28px;
            align-items: center;

            /* 디자인 스타일 */
            background-color: #f0f0f0;
            border-radius: 14px;
            /* 서버명 추가로 좌측 패딩을 10px로 유지 */
            padding: 0 5px 0 10px;
            font-size: 13px;
            color: #333;

            white-space: nowrap;
            margin-bottom: 5px;

            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            /* 부드러운 전환 효과 추가 */
        }

        /* 마우스 오버(Hover) 시: 클릭할 수 있음을 명확히 보여줌 */
        .nickname-tag:hover {
            background-color: #e8e8e8;
            /* 배경색을 약간 어둡게 변경 */
            /* 또는 미묘한 그림자 효과 추가 */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* 클릭 직후(Active) 시: 클릭됨을 강조 */
        .nickname-tag:active {
            background-color: #ccc;
            /* 클릭 시 더 어둡게 */
            transform: translateY(1px);
            /* 살짝 눌리는 듯한 효과 */
        }

        /* 키보드 포커스 시: 키보드 접근성 사용자에게도 시각적 힌트 제공 */
        .nickname-tag:focus {
            /* 기본 브라우저 아웃라인 제거 (선택 사항) */
            outline: none;
            /* 명확한 포커스 표시 (예: 파란색 테두리) */
            border: 1px solid #007bff;
        }

        /* 3. 서버 이름 스타일 (새로 추가) */
        .server-name {
            /* 닉네임보다 작게 표시하여 덜 강조 */
            font-size: 11px;
            color: #888;
            /* 회색으로 처리하여 배경처럼 보이게 */
            font-weight: normal;

            /* 서버 이름과 닉네임을 구분하는 경계선 */
            padding-right: 5px;
            margin-right: 5px;
            border-right: 1px solid #ccc;
            /* 얇은 세로선 추가 */

            /* 세로선 높이를 맞추기 위해 display 설정 */
            display: inline-block;
        }

        /* 4. 닉네임 텍스트 (수정) */
        .nickname-text {
            /* 서버 이름이 패딩을 제공하므로, margin-right는 버튼과의 간격만 남김 */
            font-weight: bold;
            /* 닉네임을 강조 */
            margin-right: 5px;
        }

        /* 5. 삭제 버튼 (x 버튼): (이전과 동일) */
        .remove-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background-color: #ccc;
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s;
        }

        .remove-btn:hover {
            background-color: #e00;
        }

        .custom-select {
            /* 1. 기본 브라우저 스타일 제거 */
            -webkit-appearance: none;
            /* Chrome, Safari */
            -moz-appearance: none;
            /* Firefox */
            appearance: none;
            /* 표준 속성 */

            /* IE 10/11의 기본 X 버튼 숨기기 (필요하다면) */
            /* IE는 표준 appearance: none;으로는 완벽히 제거되지 않을 수 있습니다. */
            /* select::-ms-expand { display: none; } */

            /* 2. 크기 및 패딩 설정 */
            padding: 8px 30px 8px 10px;
            /* 오른쪽 패딩을 넓혀 커스텀 화살표 공간 확보 */
            font-size: 16px;
            line-height: 1.5;
            height: 40px;
            /* 높이 고정 */

            /* 3. 디자인 */
            background-color: #f8f8f8;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
            /* 둥근 모서리 */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            /* 은은한 그림자 */

            /* 포커스 시 스타일 */
            transition: border-color 0.2s, box-shadow 0.2s;

            /* 5. 커스텀 화살표 추가 */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23333' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3E%3C/svg%3E");

            background-repeat: no-repeat;
            /* 화살표 위치 조정 (오른쪽에서 10px, 중앙 수직) */
            background-position: right 10px center;
            background-size: 12px;
            /* 화살표 크기 */

            /* (선택 사항) IE 10/11의 화살표 제거 */
            /* select::-ms-expand { display: none; } */
        }

        .custom-select:focus {
            border-color: #007bff;
            /* 포커스 시 파란색 테두리 */
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
            outline: none;
            /* 기본 포커스 아웃라인 제거 */
        }

        /* 4. Option 요소 스타일링 (제한적) */
        /* option 요소 자체는 브라우저가 제공하는 드롭다운 목록에서 렌더링되므로, 
            CSS 스타일링이 매우 제한적입니다 (주로 색상/배경색 정도만 가능). */
        .custom-select option {
            background-color: white;
            color: #333;
        }

        /* 2. 가장 중요한 부분: 구분 행의 아래쪽 테두리 강조 */
        .results-table .group-divider td {
            /* 얇은 기본 테두리를 굵고 진한 테두리로 덮어씁니다. */
            border-top: 2px solid #aaa;
            /* 두꺼운 회색 실선 */

            /* 또는 색상을 명확하게 구분 */
            /* border-bottom: 3px solid #007bff; */
        }

        .results-table .newer-divider td {
            /* 얇은 기본 테두리를 굵고 진한 테두리로 덮어씁니다. */
            border-top: 3px solid #1a73e8;
        }

        /* 1. 전체 컨테이너 및 레이아웃 */
        .selection-container {
            margin: 10px auto;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background-color: #ffffff;
        }

        /* 2. 제어 버튼 그룹 스타일 */
        .control-buttons {
            display: flex;
            gap: 10px;
            /* 버튼 간 간격 */
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
            /* 아래 구분선 */

            /* ⭐️ 추가: 내부 Flex Item들을 가로축(main axis) 기준으로 중앙에 정렬 */
            justify-content: center;
        }

        .select-btn {
            /* 버튼 기본 디자인 */
            padding: 8px 15px;
            font-size: 14px;
            border: 1px solid #007bff;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            white-space: nowrap;
            /* 버튼 내용이 줄바꿈되지 않도록 */
        }

        .select-btn:hover {
            background-color: #0056b3;
            border-color: #0056b3;
        }

        /* 2. ⭐️ 전체 선택 버튼 스타일 (긍정적 동작 - 녹색 계열) ⭐️ */
        .select-all-btn {
            background-color: #28a745;
            /* 녹색 */
            border-color: #28a745;
        }

        .select-all-btn:hover {
            background-color: #1e7e34;
            border-color: #1e7e34;
        }

        /* 3. ⭐️ 전체 해제 버튼 스타일 (중립적/부정적 동작 - 회색 계열) ⭐️ */
        .deselect-all-btn {
            background-color: #6c757d;
            /* 회색 */
            border-color: #6c757d;
        }

        .deselect-all-btn:hover {
            background-color: #5a6268;
            border-color: #5a6268;
        }

        /* 3. 체크박스 리스트 스타일 */
        .checkbox-list {
            display: flex;

            /* ⭐️ 추가: 내부 Flex Item들을 가로축(main axis) 기준으로 중앙에 정렬 */
            justify-content: center;

            /* ⭐️ 추가: 공간이 부족하면 다음 줄로 자동 줄 바꿈 */
            flex-wrap: wrap;

            /* 항목 간 간격 조정 */
            gap: 10px;
            /* 항목 간의 가로/세로 간격을 10px로 설정 */
            padding-top: 5px;
        }

        .checkbox-list label {
            display: flex;
            align-items: center;
            font-size: 15px;
            padding: 5px 8px;
            /* 패딩을 약간 늘려 가독성 확보 */
            cursor: pointer;
            transition: background-color 0.1s;
            border-radius: 3px;

            /* ⭐️ 추가: 체크박스들이 한 줄에 유지되도록 강제 */
            white-space: nowrap;
        }

        /* 마우스 오버 시 미묘한 배경색 변화로 상호작용성 강조 */
        .checkbox-list label:hover {
            background-color: #f8f8f8;
        }

        /* 기본 체크박스 스타일은 브라우저에 맡기고, 여백만 조정 */
        .checkbox-list input[type="checkbox"] {
            margin-right: 8px;
            /* 체크박스 자체의 크기를 조절하고 싶다면 appearance: none 후 커스텀 스타일 적용 필요 */
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>던파 득템 유효성 검사기</h1>
        <div id="search-history-container" class="search-history-container">
            <div class="nickname-tag">
                <span class="server-name"> </span>
                <span class="nickname-text"> </span>
                <button class="remove-btn">x</button>
            </div>
        </div>
        <div class="input-area">
            <select id="serverSelect" onchange="saveSelectedServerId(this.value)" class="custom-select">
            </select>
            <input type="text" id="characterNameInput" placeholder="캐릭터명을 입력하세요">
            <button id="searchButton" onclick="startSearch()">조회</button>
        </div>

        <div id="rarityFilters" class="selection-container" style="margin-top: 15px;">
            <div class="checkbox-list">
                <label>
                    <input type="checkbox" id="filterTaecho" value="태초" onchange="filterTimeline()" checked> 태초
                </label>
                <label>
                    <input type="checkbox" id="filterEpic" value="에픽" onchange="filterTimeline()" checked> 에픽
                </label>
                <label>
                    <input type="checkbox" id="filterLegendary" value="레전더리" onchange="filterTimeline()" checked> 레전더리
                </label>
            </div>
        </div>

        <div id="setFilters" class="selection-container">
            <div class="control-buttons">
                <button id="select-only-mine" class="select-btn">내 세트만</button>
                <button class="select-btn" data-target="group-left4">왼쪽 4개만</button>
                <button class="select-btn" data-target="group-left8">왼쪽 8개만</button>
                <button id="select-set-all" class="select-btn select-all-btn" data-target="group-all">전체 선택</button>
                <button id="deselect-set-all" class="select-btn deselect-all-btn">전체 해제</button>
            </div>

            <div id="setCheckboxList" class="checkbox-list">
                <label>
                    <input type="checkbox" id="filterGold" value="영원히 이어지는 황금향 세트"
                        data-group="group-left4 group-left8 group-all" onchange="filterTimeline()" checked> 황금향
                </label>
                <label>
                    <input type="checkbox" id="filterCleanse" value="칠흑의 정화 세트"
                        data-group="group-left4 group-left8 group-all" onchange="filterTimeline()" checked> 정화
                </label>
                <label>
                    <input type="checkbox" id="filterDrake" value="용투장의 난 세트"
                        data-group="group-left4 group-left8 group-all" onchange="filterTimeline()" checked> 용투
                </label>
                <label>
                    <input type="checkbox" id="filterSeren" value="세렌디피티 세트"
                        data-group="group-left4 group-left8 group-all" onchange="filterTimeline()" checked> 세렌
                </label>
                <label>
                    <input type="checkbox" id="filterEtte" value="에테리얼 오브 아츠 세트" data-group="group-left8 group-all"
                        onchange="filterTimeline()" checked> 에테
                </label>
                <label>
                    <input type="checkbox" id="filterShadow" value="그림자에 숨은 죽음 세트" data-group="group-left8 group-all"
                        onchange="filterTimeline()" checked> 그림자
                </label>
                <label>
                    <input type="checkbox" id="filterVal" value="고대 전장의 발키리 세트" data-group="group-left8 group-all"
                        onchange="filterTimeline()" checked> 발키리
                </label>
                <label>
                    <input type="checkbox" id="filterFairy" value="소울 페어리 세트" data-group="group-left8 group-all"
                        onchange="filterTimeline()" checked> 페어리
                </label>
                <label>
                    <input type="checkbox" id="filterMa" value="마력의 영역 세트" data-group="group-all"
                        onchange="filterTimeline()" checked> 마력
                </label>
                <label>
                    <input type="checkbox" id="filterNature" value="압도적인 자연 세트" data-group="group-all"
                        onchange="filterTimeline()" checked> 자연
                </label>
                <label>
                    <input type="checkbox" id="filterTribe" value="무리 사냥의 길잡이 세트" data-group="group-all"
                        onchange="filterTimeline()" checked> 무리
                </label>
                <label>
                    <input type="checkbox" id="filterUnlimit" value="한계를 넘어선 에너지 세트" data-group="group-all"
                        onchange="filterTimeline()" checked> 각몰
                </label>
            </div>
        </div>

        <p id="totalRowCount" style="font-weight: bold; margin: 10px 0;">총 타임라인 수: 0</p>

        <div id="infoNotice"
            style="margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; background: url('https://img-api.neople.co.kr/df/servers/cain/characters/4ecd3f9eea4b6dd87044a9d9323efd20?zoom=1') no-repeat center; color: #333; border-radius: 4px;">
            <strong>✅ 유효 확률 계산 안내</strong>
            <p style="margin-top: 5px; margin-bottom: 0; font-size: 0.95em;">
            <ul>
                <li>이 표는 <b>무기</b> 및 <b>고유를 제외한</b> 타임라인을 모두 보여줍니다. <br /></li>
                <li>항아리, 업그레이드, 초월 등은 표에서 <b>제외</b>지만 확률 계산에 포함입니다.<br /></li>
                <li>'유효 확률'은 아이템을 획득할 <b>당시</b> 기준으로 그 세트의 유효 <b>부위</b> 확률입니다. <br /></li>
                <li>운은 먹었을 때의 결과운을 의미합니다. 많거나 적게 뜬다는 의미가 아닙니다. <br /></li>
            </ul>
            </p>
        </div>

        <div id="status"></div>
        <table class="results-table">
            <thead>
                <tr>
                    <th>획득 시간</th>
                    <th>아이템명</th>
                    <th>등급</th>
                    <th>세트</th>
                    <th>부위</th>
                    <th>유효 확률</th>
                    <th>유효 여부</th>
                    <th>운</th>
                </tr>
            </thead>
            <tbody id="resultsContainer">
            </tbody>
        </table>
    </div>

    <script>

        // 제공된 서버 데이터
        const serverData = [
            { "serverId": "cain", "serverName": "카인" },
            { "serverId": "diregie", "serverName": "디레지에" },
            { "serverId": "siroco", "serverName": "시로코" },
            { "serverId": "prey", "serverName": "프레이" },
            { "serverId": "casillas", "serverName": "카시야스" },
            { "serverId": "hilder", "serverName": "힐더" },
            { "serverId": "anton", "serverName": "안톤" },
            { "serverId": "bakal", "serverName": "바칼" }
        ];

        // 🚨 모든 타임라인 데이터를 저장할 전역 변수 🚨
        let allTimelinePages = [];
        let filteredTimelinePages = [];

        let chanceSeqTimeline = [];

        // 🚨 아이템 획득 시점까지의 세트 부위 점유 상태를 추적하는 객체
        // Key: "세트이름-희귀도" (예: "세렌디피티 세트-에픽")
        // Value: Set 객체로, 이미 획득한 슬롯 부위 이름들을 저장합니다.
        let setSlotTracker = {};

        // 🚨 희귀도 순위 정의 (높을수록 낮은 순위 값) 🚨
        // 비교를 위해 순위를 부여합니다.
        const RARITY_RANK = {
            '태초': 1,
            '에픽': 2,
            '레전더리': 3
            // 무기는 제외, 나머지 희귀도는 VALID_RARITIES에서 제외
        };

        // 전체 세트 부위 수 (무기 제외 11개)
        const TOTAL_SET_SLOTS = 11;
        // 유효 희귀도 목록
        const VALID_RARITIES = ['태초', '에픽', '레전더리'];

        // 🚨 태초 아이템의 실제 세트 부위 (액세서리 3종) 🚨
        const TAECHO_SLOTS = ['팔찌', '목걸이', '반지'];
        const MAX_TAECHO_SLOTS = TAECHO_SLOTS.length; // 3

        const VALID_SLOTS = ['상의', '머리어깨', '하의', '벨트', '신발', '팔찌', '목걸이', '반지', '보조장비', '마법석', '귀걸이'];

        const VALID_CODES = [505, 507, 513];

        // --- 설정 및 상수 ---
        // *** 프록시 서버의 기본 경로를 정의합니다. ***
        // Vercel에 배포된 경우, /api/proxy는 api/proxy.js 서버리스 함수로 연결됩니다.
        const PROXY_BASE_URL = "/api/proxy/df"; // Neople API의 /df 이전 경로를 프록시로 지정

        let SERVER_ID = "cain";

        // 아이템 등급 우선순위 (높을수록 좋음)
        const RARITY_ORDER = {
            "태초": 3,
            "에픽": 2,
            "레전더리": 1
        };

        const lastTimelineDate = null;

        let mySet = '';

        // --- DOM 요소 ---
        const charInput = document.getElementById('characterNameInput');
        const searchBtn = document.getElementById('searchButton');
        const statusEl = document.getElementById('status');
        const resultsEl = document.getElementById('resultsContainer');

        // DB 연결 객체를 저장할 변수 (전역적으로 사용)
        let db;
        const DB_NAME = 'dnfTimeline';
        const DB_VERSION = 1;
        const CHARACTER_STORE = 'characters';
        const ITEM_STORE = 'items';
        const TIMELINE_STORE = 'timelines';
        const DEFAULT_ID = 1;

        /**
 * 캐릭터명 입력창에서 Enter 키를 눌렀을 때 startSearch() 함수를 호출합니다.
 * @param {Event} event - 키보드 이벤트 객체
 */
        function handleEnterKey(event) {
            // Enter 키의 keyCode는 13입니다.
            if (event.key === 'Enter' || event.keyCode === 13) {
                event.preventDefault(); // 기본 Enter 동작(폼 제출 등) 방지
                startSearch();         // 조회 시작 함수 호출
            }
        }

        // --- API 호출 함수 ---

        // 1. 캐릭터 ID 조회
        function getCharacterId(characterName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE], 'readwrite');
                const store = transaction.objectStore(CHARACTER_STORE);
                const getRequest = store.get(DEFAULT_ID);
                getRequest.onsuccess = (event) => {
                    const characterObject = event.target.result;

                    if (characterObject) {
                        const serverObject = characterObject[SERVER_ID];
                        if (!serverObject) {
                            store.put({ ...characterObject, [SERVER_ID]: {} }, DEFAULT_ID);
                        } else {
                            const characterId = serverObject[characterName];
                            if (!characterId) {
                                resolve(getCharacterIdApi());
                            } else {
                                resolve(characterId);
                            }
                        }
                    } else {
                        console.log(`characters를 찾을 수 없습니다.`);
                        resolve(getCharacterIdApi());
                    }
                };

                getRequest.onerror = (event) => {
                    console.error("데이터 조회 오류:", event.target.error);
                    resolve(getCharacterIdApi());
                };


                function getCharacterIdApi() {
                    return new Promise((resolve, reject) => {
                        const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters?characterName=${encodeURIComponent(characterName)}`;
                        fetch(url).then((response) => {
                            if (!response.ok) reject("캐릭터 ID 조회 실패");
                            return response.json();
                        }).then((data) => {
                            if (!data.rows || data.rows.length === 0) reject("캐릭터를 찾을 수 없습니다.");
                            const character = data.rows[0];
                            const transaction = db.transaction([CHARACTER_STORE], 'readwrite');
                            const store = transaction.objectStore(CHARACTER_STORE);
                            const getReq = store.get(DEFAULT_ID);
                            getReq.onsuccess = (event) => {
                                const characterObject = event.target.result || {};
                                const serverObject = characterObject[SERVER_ID] || {};
                                const putReq = store.put({ ...characterObject, [SERVER_ID]: { ...serverObject, [character.characterName]: character.characterId } }, DEFAULT_ID);
                                putReq.onsuccess = (event) => {
                                    resolve(character.characterId);
                                };
                                putReq.onerror = (event) => {
                                    reject(`put character id error`, event.target.error);
                                }
                            }
                            getReq.onerror = (event) => {
                                reject(`get character id error`, event.target.error);
                            }
                        });
                    })
                }

            });
        }

        // 1.5. 캐릭터 set 조회
        async function getCharacterEquipment(characterId) {
            const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters/${characterId}/equip/equipment?`;
            const response = await fetch(url);
            if (!response.ok) throw new Error("캐릭터 장비 조회 실패");
            const data = await response.json();
            if (!data.equipment || data.equipment.length === 0) throw new Error("캐릭터 장비 조회를 실패했습니다.");
            return data.equipment.find(e => e.setItemName)?.setItemName;
        }

        // 2. 타임라인 조회 (월별로 반복 호출)
        async function getAllTimelinePages(characterId) {
            let allTimelineRows = [];
            let currentMonthStart = new Date('2025-01-01');
            let start = new Date('2025-01-01');
            const timelines = await getTimelines(characterId);
            const lastTimeline = timelines[timelines.length - 1];
            if (lastTimeline) {
                start = new Date(lastTimeline.date);
                const startMinute = start.getMinutes();
                start.setMinutes(startMinute + 1);
            }
            const today = new Date();

            while (start < today) {
                // 다음 달 1일 계산
                let nextMonthStart = new Date(start.getFullYear(), start.getMonth() + 1, 1);
                if (nextMonthStart > today) {
                    nextMonthStart = today;
                }

                const startDateStr = formatDate(start) + formatToApiTime(start);
                const endDateStr = nextMonthStart === today ? formatDate(nextMonthStart) + formatToApiTime(nextMonthStart) : formatDate(nextMonthStart);

                statusEl.textContent = `${start.getFullYear()}년 ${start.getMonth() + 1}월 타임라인 조회 중...`;

                const url = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters/${characterId}/timeline?limit=100&code=505,507,513,504,511,516,514&startDate=${startDateStr}&endDate=${endDateStr}`;

                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.timeline && data.timeline.rows) {
                        allTimelineRows.push(...(data.timeline.rows.reverse()));
                    }
                    if (data.timeline.next) {
                        const urlNext = `${PROXY_BASE_URL}/servers/${SERVER_ID}/characters/${characterId}/timeline?next=${data.timeline.next}`;
                        const responseNext = await fetch(urlNext);
                        const dataNext = await responseNext.json();
                        if (dataNext.timeline && dataNext.timeline.rows) {
                            allTimelineRows.push(...(dataNext.timeline.rows.reverse()));
                        }
                    }
                } catch (e) {
                    console.error(`${startDateStr} 타임라인 조회 실패:`, e);
                    // 한두 달 실패해도 계속 진행
                }

                // 다음 달로 이동
                start = nextMonthStart;
            }

            const allItemIds = [];
            allTimelineRows.forEach(row => {
                if (row.data && row.data.itemId) {
                    // itemId가 쉼표로 분리되어 있을 수 있으므로 모두 추출
                    const ids = row.data.itemId.split(',').map(id => id.trim()).filter(id => id.length > 0);
                    allItemIds.push(...ids);
                }
            });

            // 수집된 모든 아이템 ID에 대해 다중 조회 함수 호출
            await getTimelineItemDetails(allItemIds);

            const result = [...(timelines.map((timeline) => ({ ...timeline, from: 'db' }))), ...(allTimelineRows.map((timeline) => ({ ...timeline, from: 'api' })))];
            await setTimelines(characterId, result);

            return result;
        }

        // ⚠️ 추가: API가 요구하는 hhmm 형식으로 시간을 포맷하는 헬퍼 함수
        function formatToApiTime(date) {
            const hh = String(date.getHours()).padStart(2, '0');
            const mm = String(date.getMinutes()).padStart(2, '0');
            return `T${hh}${mm}`;
        }

        // 타임라인에서 필요한 모든 아이템 ID 목록을 받아 정보를 조회하고 캐시에 저장합니다.
        async function getTimelineItemDetails(allItemIds) {
            const uniqueItemIds = Array.from(new Set(allItemIds));
            const itemsHas = await getAllItemIds();
            const itemIdsToFetch = arrayDifference(uniqueItemIds, itemsHas);

            if (itemIdsToFetch.length === 0) {
                console.log("[Multi-Fetch] All items found in cache.");
                return; // 조회할 아이템이 없으면 종료
            }

            console.log(`[Multi-Fetch] Need to fetch ${itemIdsToFetch.length} items.`);

            // 2. 아이템 ID를 최대 15개씩 묶어 API 호출
            const CHUNK_SIZE = 15;
            const fetchPromises = [];

            for (let i = 0; i < itemIdsToFetch.length; i += CHUNK_SIZE) {
                const chunk = itemIdsToFetch.slice(i, i + CHUNK_SIZE);
                const itemIdsParam = chunk.join(','); // 아이템 ID들을 콤마로 연결

                // 다중 조회 API URL
                const url = `${PROXY_BASE_URL}/multi/items?itemIds=${encodeURIComponent(itemIdsParam)}`;

                // 프록시 서버에 요청을 보내고 Promise를 배열에 저장
                fetchPromises.push(
                    fetch(url)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`다중 아이템 조회 실패: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            const works = [];
                            // 3. 응답 데이터를 파싱하여 db에 저장
                            if (data.rows) {
                                for (const itemData of data.rows) {
                                    works.push(setItemDetail(itemData));
                                }
                            }
                            return Promise.all(works);
                        })
                        .catch(error => {
                            console.error(`아이템 묶음 조회 중 오류 발생: ${error.message}`);
                            // 오류 발생 시 해당 아이템들의 캐시 항목은 undefined로 남습니다.
                        })
                );
            }

            // 4. 모든 API 호출이 완료될 때까지 기다립니다.
            await Promise.all(fetchPromises);
        }

        // --- 메인 로직 ---
        async function startSearch() {
            const characterName = charInput.value.trim();
            if (!characterName) {
                alert("캐릭터명을 입력해주세요.");
                return;
            }

            // 초기화
            searchBtn.disabled = true;
            charInput.readonly = true;
            statusEl.textContent = "조회를 시작합니다...";
            resultsEl.innerHTML = "";

            try {
                // 1. 캐릭터 ID 가져오기
                statusEl.textContent = "캐릭터 ID 조회 중...";
                const characterId = await getCharacterId(characterName);
                const el = document.getElementById('infoNotice');
                el.style.background = `url('https://img-api.neople.co.kr/df/servers/${SERVER_ID}/characters/${characterId}?zoom=1') no-repeat center`

                loadAndDisplayTags();
                resetGlobalData();

                // 2. 모든 타임라인 데이터 가져오기 (월별)
                const [set, allTimelineRows] = await Promise.all([getCharacterEquipment(characterId), getAllTimelinePages(characterId)]);
                mySet = set;

                if (allTimelineRows.length === 0) {
                    statusEl.textContent = "조회 기간 내 아이템 획득 기록이 없습니다.";
                    searchBtn.disabled = false;
                    charInput.readonly = false;
                    return;
                }

                const itemDetails = await getAllItemDetails();

                // 3. 타임라인 처리 (오래된 순으로 정렬)
                statusEl.textContent = "타임라인 처리 중... (아이템 상세 정보 조회)";
                allTimelineRows.sort((a, b) => new Date(a.date) - new Date(b.date)); // 획득순(오름차순) 정렬

                const processedItems = [];
                const highestAcquiredRarity = {}; // Key: "세트명_부위명", Value: 등급 점수(3, 2, 1)

                let processedCount = 0;
                for (const itemDrop of allTimelineRows) {
                    processedCount++;
                    statusEl.textContent = `타임라인 처리 중... (${processedCount}/${allTimelineRows.length})`;

                    const dropData = itemDrop.data;
                    const itemId = dropData.itemId;
                    const itemRarity = dropData.itemRarity;
                    const dropDate = itemDrop.date;
                    const code = itemDrop.code;

                    // 3-1. 아이템 상세 정보 조회
                    const details = itemDetails[itemId];

                    // 3-2. 유효성 검사: 115레벨이 아니거나, 세트 아이템이 아니면 무시
                    if (!details || details.itemAvailableLevel !== 115 || !details.setItemName) {
                        continue;
                    }

                    const setItemName = details.setItemName;
                    const itemTypeDetail = details.itemTypeDetail;

                    if (!VALID_SLOTS.includes(itemTypeDetail)) continue;

                    // 3-3. 유효성 로직 실행
                    const itemKey = `${setItemName}_${itemTypeDetail}`;
                    const currentRarityScore = RARITY_ORDER[itemRarity] || 0;
                    const highestRarityScore = highestAcquiredRarity[itemKey] || 0;

                    let isValid = false;

                    // 🚨 희귀도별 스타일을 저장할 변수 🚨
                    let itemStyle = '';

                    // 1. 아이템 희귀도에 따른 스타일 결정
                    if (itemRarity === '레전더리') {
                        itemStyle = 'color: rgb(239, 112, 0);';
                    } else if (itemRarity === '에픽') {
                        itemStyle = 'color: rgb(239, 169, 0);';
                    } else if (itemRarity === '태초') {
                        // 그라데이션은 CSS background로 적용하는 것이 일반적이나, 
                        // 텍스트에만 적용하려면 웹킷(WebKit) 속성을 사용해야 합니다.
                        // 여기서는 텍스트 색상을 설정하고, 셀 배경에 적용하는 방식으로 처리하겠습니다.
                        itemStyle = 'color: #3057a6; font-weight: bold; background-image: linear-gradient(180deg, #55e95b, #3057a6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;';
                        // ⚠️ 주의: 웹킷(Chrome, Safari) 브라우저에서만 정상적으로 텍스트 그라데이션이 보입니다.
                    } else {
                        itemStyle = ''; // 기타 희귀도는 기본 스타일
                    }


                    let probabilityContent = '';
                    let styleClass = ''; // 새로 추가된 스타일 변수
                    let resultClass = 'result-normal';
                    let roundedProbability = 0;
                    let resultText = '';

                    // 2. 슬롯 추적기 구조: setSlotTracker[setName] = Map<Rarity, Set<SlotName>>
                    if (!setSlotTracker[setItemName]) {
                        setSlotTracker[setItemName] = {};
                    }
                    if (!setSlotTracker[setItemName][itemRarity]) {
                        setSlotTracker[setItemName][itemRarity] = new Set();
                    }

                    // 3. 현재 희귀도의 순위 확인
                    const targetRank = RARITY_RANK[itemRarity];
                    let filledSlotCount = 0;
                    const countedSlots = new Set(); // 중복 부위 카운트를 막기 위한 Set

                    // 4. 이미 채워진 부위 카운트 (순위가 같거나 더 높은 희귀도만 카운트)
                    // '더 높은 희귀도'는 순위 값이 '더 낮거나 같은' 경우입니다.
                    for (const r in RARITY_RANK) {
                        if (RARITY_RANK[r] <= targetRank) {
                            if (setSlotTracker[setItemName][r]) {
                                setSlotTracker[setItemName][r].forEach(slot => {
                                    // 🚨 태초 등급 아이템일 경우, 슬롯을 3개로 제한 🚨
                                    if (itemRarity === '태초' && !TAECHO_SLOTS.includes(slot)) {
                                        return; // 태초가 아닌 부위는 카운트하지 않음
                                    }
                                    countedSlots.add(slot);
                                });
                            }
                        }
                    }
                    // 5. 태초 아이템의 경우, 카운팅 된 부위 중 최대 3개만 유효 부위로 간주
                    if (itemRarity === '태초') {
                        filledSlotCount = Math.min(countedSlots.size, MAX_TAECHO_SLOTS);
                    } else {
                        filledSlotCount = countedSlots.size;
                    }

                    // 5. 확률 계산
                    if (filledSlotCount < TOTAL_SET_SLOTS) {
                        // 남은 유효 부위 개수: 11 - 현재 획득한 부위 개수
                        let remainingValidSlots = TOTAL_SET_SLOTS - filledSlotCount;
                        let probability = (remainingValidSlots / TOTAL_SET_SLOTS) * 100;
                        if (itemRarity === '태초') {
                            remainingValidSlots = MAX_TAECHO_SLOTS - filledSlotCount;
                            probability = (remainingValidSlots / MAX_TAECHO_SLOTS) * 100;
                        }

                        // 소수점 첫째 자리에서 반올림
                        roundedProbability = Math.round(probability);
                        probabilityContent = `${roundedProbability}%`;

                        // 🚨 확률 구간에 따른 스타일 클래스 결정 🚨
                        if (roundedProbability <= 25) {
                            styleClass = 'prob-low';
                        } else if (roundedProbability <= 50) {
                            styleClass = 'prob-mid-low';
                        } else if (roundedProbability <= 75) {
                            styleClass = 'prob-mid-high';
                        } else { // 76% ~ 100%
                            styleClass = 'prob-high';
                        }
                    } else {
                        // 이미 11부위를 다 채운 경우
                        probabilityContent = '0%';
                        styleClass = 'prob-low'; // 0%는 가장 낮은 구간으로 설정
                    }

                    // 6. 슬롯 트래커 업데이트 (확률 계산 후, 현재 아이템 부위를 추가)
                    // 7. 슬롯 트래커 업데이트
                    // 🚨 태초일 경우, 트래커에 추가할 때도 3개 부위만 추가하도록 제약 🚨
                    if (itemRarity === '태초' && !TAECHO_SLOTS.includes(itemTypeDetail)) {
                        // 태초 아이템이 아닌 부위 (예: 무기)로 잘못 들어왔다면 트래커에 추가하지 않음
                    } else {
                        setSlotTracker[setItemName][itemRarity].add(itemTypeDetail);
                    }

                    // 현재 획득한 아이템 등급이 이전에 획득한 최고 등급보다 높아야 유효
                    if (currentRarityScore > highestRarityScore) {
                        isValid = true;
                        highestAcquiredRarity[itemKey] = currentRarityScore; // 최고 등급 갱신
                    }

                    if (roundedProbability <= 20 && isValid) {
                        resultClass = 'result-success-low-prob';
                        resultText = '운도실력';
                    } else if (roundedProbability >= 80 && !isValid) {
                        resultClass = 'result-fail-high-prob';
                        resultText = '나만운없어';
                    } else if (itemRarity === '태초' && !isValid) {
                        resultClass = 'result-fail-high-prob';
                        resultText = '태초중복☠';
                    } else if (itemRarity === '태초' && isValid && set === setItemName) {
                        resultClass = 'result-success-low-prob';
                        resultText = '내태초❤';
                    } else if (itemRarity === '태초' && isValid && roundedProbability <= 34) {
                        resultClass = 'result-success-low-prob';
                        resultText = '태초3셋sex';
                    }

                    let setClass = '';
                    if (set === setItemName) {
                        setClass = 'highlight-set';
                    }


                    // 아이템 연속 운 설정
                    if (chanceSeqTimeline?.length > 0) {
                        const seqLength = chanceSeqTimeline.length;
                        const last = chanceSeqTimeline[seqLength - 1];

                        if (isValidCode(code) && isValid !== last.isValid) {
                            const tempSeqTimeline = [...chanceSeqTimeline];

                            // 연속 정보 초기화
                            chanceSeqTimeline = [];

                            // 마지막 아이템에 결과 추가
                            if (seqLength >= 3) {
                                let validSeqLength = 0;
                                for (let i = seqLength; i >= 3; i--) {
                                    const slicedList = tempSeqTimeline.slice(-i);
                                    const slicedSeqLength = slicedList.length;
                                    const chanceSum = slicedList.reduce((acc, cur) => acc + cur.probability, 0);
                                    if (chanceSum <= 40 * slicedSeqLength && last.isValid) {
                                        processedItems[processedItems.length - 1].resultClass = 'result-success-low-prob';
                                        processedItems[processedItems.length - 1].resultText = '💯'.repeat(slicedSeqLength);
                                        break;
                                    } else if (chanceSum >= 60 * slicedSeqLength && !last.isValid) {
                                        processedItems[processedItems.length - 1].resultClass = 'result-fail-high-prob';
                                        processedItems[processedItems.length - 1].resultText = '☠'.repeat(slicedSeqLength);
                                        break;
                                    }
                                }

                            }


                        }
                    }
                    if (isValidCode(code)) {
                        chanceSeqTimeline.push({
                            isValid: isValid,
                            probability: roundedProbability,
                            itemName: dropData.itemName
                        });
                    }




                    processedItems.push({
                        date: dropDate,
                        itemName: dropData.itemName,
                        rarity: itemRarity,
                        setName: setItemName,
                        slot: itemTypeDetail,
                        isValid: isValid,
                        probabilityContent: probabilityContent,
                        styleClass: styleClass,
                        style: itemStyle,
                        resultClass: resultClass,
                        resultText: resultText,
                        setClass: setClass,
                        code: code,
                        from: itemDrop.from
                    });
                }


                // 🚨 전역 변수에 전체 데이터 저장 🚨
                allTimelinePages = processedItems;
                filterTimeline();

            } catch (error) {
                console.error(error);
                statusEl.textContent = `오류 발생: ${error.message}`;
            } finally {
                searchBtn.disabled = false;
                charInput.readonly = false;
                if (!statusEl.textContent.startsWith("오류")) {
                    statusEl.textContent = "조회 완료!";
                }
            }
        }

        // --- 유틸리티 함수 ---

        // 결과 테이블에 표시
        function displayResults() {
            const items = filteredTimelinePages;
            // 최신순(내림차순)으로 정렬하여 표시
            // items.sort((a, b) => new Date(b.date) - new Date(a.date));
            if (items[0].date < items[items.length - 1].date) { items.reverse(); }

            if (items.length === 0) {
                resultsEl.innerHTML = '<tr><td colspan="6">표시할 115레벨 세트 아이템이 없습니다.</td></tr>';
                return;
            }

            let html = "";
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const prevItem = items[Math.max(i - 1, 0)];
                const validityClass = item.isValid ? 'valid-true' : 'valid-false';
                const validityText = item.isValid ? '유효' : '중복';
                let setClass = item.setClass;

                if (i > 0 && new Date(item.date).getMonth() !== new Date(prevItem.date).getMonth()) {
                    setClass += ' group-divider';
                }

                if (i > 0 && item.from !== prevItem.from) {
                    setClass += ' newer-divider';
                }

                html += `
                    <tr class="${setClass}">
                        <td>${item.date}</td>
                        <td style="${item.style}">${item.itemName}</td>
                        <td style="${item.style}">${item.rarity}</td>
                        <td>${item.setName}</td>
                        <td>${item.slot}</td>
                        <td class="probability-cell ${item.styleClass}">${item.probabilityContent}</td>
                        <td class="${validityClass}">${validityText}</td>
                        <td class="${item.resultClass}">${item.resultText}</td>
                    </tr>
                `;
            }
            resultsEl.innerHTML = html;

            const rowCountElement = document.getElementById('totalRowCount'); // 🚨 새로운 요소 가져오기 🚨
            // 3. 총 행 수 업데이트
            if (rowCountElement) {
                rowCountElement.textContent = `총 타임라인 수: ${items.length}`;
            }

        }

        // 날짜를 'YYYYMMDD' 형식의 문자열로 변환
        function formatDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}${month}${day}`;
        }

        /**
 * 체크박스 상태에 따라 타임라인 데이터를 필터링하고 노출합니다.
 */
        function filterTimeline() {
            if (!allTimelinePages || allTimelinePages.length === 0) {
                return; // 데이터가 없거나 테이블이 준비되지 않았으면 종료
            }

            // 1. 체크된 등급(Rarities) 확인
            const checkedRarities = [];
            if (document.getElementById('filterTaecho')?.checked) checkedRarities.push('태초');
            if (document.getElementById('filterEpic')?.checked) checkedRarities.push('에픽');
            if (document.getElementById('filterLegendary')?.checked) checkedRarities.push('레전더리');

            // 체크된 등급이 없으면 모든 데이터를 노출하지 않습니다.
            if (checkedRarities.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center;">선택된 아이템 등급이 없습니다.</td></tr>';
                return;
            }

            // 2. 체크된 세트(Sets) 확인
            const checkedSets = [];
            const setGold = document.getElementById('filterGold');
            const setCleanse = document.getElementById('filterCleanse');
            const setDrake = document.getElementById('filterDrake');
            const setSeren = document.getElementById('filterSeren');
            const setEtte = document.getElementById('filterEtte');
            const setShadow = document.getElementById('filterShadow');
            const setVal = document.getElementById('filterVal');
            const setFairy = document.getElementById('filterFairy');
            const setMa = document.getElementById('filterMa');
            const setNature = document.getElementById('filterNature');
            const setTribe = document.getElementById('filterTribe');
            const setUnlimit = document.getElementById('filterUnlimit');

            [setGold, setCleanse, setDrake, setSeren, setEtte, setShadow, setVal, setFairy, setMa, setNature, setTribe, setUnlimit]
                .forEach((set) => {
                    if (set.checked) checkedSets.push(set.value);
                })

            // 체크된 세트가 없으면 모든 데이터를 노출하지 않습니다.
            if (checkedSets.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center;">선택된 아이템 등급이 없습니다.</td></tr>';
                return;
            }

            // 2. 전체 데이터를 순회하며 필터링
            filteredTimelinePages = allTimelinePages.filter(row => checkedRarities.includes(row.rarity)).filter(row => checkedSets.includes(row.setName)).filter(row => isValidCode(row.code));

            displayResults();
        }

        function resetGlobalData() {
            allTimelinePages = [];
            filteredTimelinePages = [];

            // 🚨 아이템 획득 시점까지의 세트 부위 점유 상태를 추적하는 객체
            // Key: "세트이름-희귀도" (예: "세렌디피티 세트-에픽")
            // Value: Set 객체로, 이미 획득한 슬롯 부위 이름들을 저장합니다.
            setSlotTracker = {};

            chanceSeqTimeline = [];
        }

        // ------------------------------------------------------------------
        // 🚨 DOM 로드 후 이벤트 리스너 연결 🚨
        document.addEventListener('DOMContentLoaded', (event) => {
            const inputElement = document.getElementById('characterNameInput');

            // input 요소가 존재하는지 확인 후 이벤트 리스너 연결
            if (inputElement) {
                inputElement.addEventListener('keydown', handleEnterKey);
            }
        });

        // 1. 드롭다운 옵션을 생성하고 추가하는 함수
        function populateServerOptions() {
            const selectElement = document.getElementById('serverSelect');

            serverData.forEach((server, index) => {
                const option = document.createElement('option');
                option.value = server.serverId; // option의 value에 serverId 저장
                option.textContent = server.serverName; // 사용자에게 보이는 텍스트

                // 첫 번째 항목(index === 0)을 기본 선택값으로 지정
                if (index === 0) {
                    option.selected = true;
                }

                selectElement.appendChild(option);
            });
        }

        // 2. 선택된 값을 전역 변수에 저장하고 화면에 표시하는 함수
        function saveSelectedServerId(serverId) {
            // 전역 변수에 값 저장
            SERVER_ID = serverId;
        }

        // 페이지 로드 시 옵션 생성 함수 실행
        document.addEventListener('DOMContentLoaded', populateServerOptions);

        function isValidCode(code) {
            return VALID_CODES.includes(code);
        }







        /**
         * 1. DB 연결 시도 (최초 1회 실행)
         */
        function openDatabase() {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            // DB 버전 업그레이드 또는 최초 생성 시 실행됨
            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // 객체 저장소(테이블) 생성
                if (!db.objectStoreNames.contains(CHARACTER_STORE)) {
                    db.createObjectStore(CHARACTER_STORE, { autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(ITEM_STORE)) {
                    db.createObjectStore(ITEM_STORE, { autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(TIMELINE_STORE)) {
                    db.createObjectStore(TIMELINE_STORE, { autoIncrement: true });
                }
                console.log('데이터베이스 구조 설정 완료.');
            };

            // DB 연결 성공 시 실행됨
            request.onsuccess = (event) => {
                db = event.target.result; // 전역 변수에 DB 객체 저장
                console.log('IndexedDB 연결 성공.');

                // ★★★ 연결 성공 후 데이터 로드 시작 ★★★
                loadAndDisplayTags();
            };

            // DB 연결 실패 시 실행됨
            request.onerror = (event) => {
                console.error('IndexedDB 연결 오류:', event.target.error);
            };
        }

        /**
        * DB에서 데이터를 조회하여 닉네임 태그를 생성하고 추가합니다.
        */
        async function loadAndDisplayTags() {
            // 1. DB 연결 확인
            if (!db) {
                console.error("IndexedDB 연결이 완료되지 않았습니다.");
                // 필요하다면 여기서 openDatabase()를 다시 호출하여 연결을 시도할 수 있습니다.
                return;
            }

            const container = document.querySelector('.search-history-container');
            if (!container) return;

            console.log('IndexedDB characters fetch and append tags');

            // 기존 내용을 비웁니다.
            container.innerHTML = '';

            try {
                // 2. Promise 기반의 getCharacters 함수를 사용하여 모든 캐릭터 데이터 조회
                // (getCharacters 함수가 Promise를 반환하므로 await 사용 가능)
                const characterList = await getCharacters();

                // 3. 조회된 데이터를 순회하며 태그 생성
                characterList.forEach(charactersObject => {
                    for (const [serverId, serverCharacters] of Object.entries(charactersObject)) {
                        Object.keys(serverCharacters).forEach((nickname) => {
                            const serverName = serverData.find(((server) => server.serverId === serverId)).serverName;
                            const tag = createNicknameTag(serverName, nickname);
                            container.appendChild(tag);
                        })
                    }
                });

            } catch (error) {
                console.error("데이터 조회 및 태그 생성 중 오류 발생:", error);
                container.innerHTML = '<li>검색 기록을 불러오는 데 실패했습니다.</li>';
            }
        }

        function getCharacters() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE], 'readonly');
                const store = transaction.objectStore(CHARACTER_STORE);

                // 커서를 사용하여 모든 데이터를 조회합니다.
                const request = store.openCursor();
                let results = [];

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        results.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(results); // 모든 데이터 배열을 resolve
                    }
                };

                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }


        /**
         * 개별 닉네임 태그 (HTML 요소)를 생성합니다.
         */
        function createNicknameTag(serverName, nickname) {
            const tagDiv = document.createElement('div');
            tagDiv.className = 'nickname-tag';

            // 서버 이름 요소
            const serverSpan = document.createElement('span');
            serverSpan.className = 'server-name';
            serverSpan.textContent = serverName;

            // 닉네임 요소
            const nicknameSpan = document.createElement('span');
            nicknameSpan.className = 'nickname-text';
            nicknameSpan.textContent = nickname;

            // 삭제 버튼 요소
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = 'x';

            // 삭제 이벤트 리스너 추가
            removeBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                // IndexedDB 삭제 로직 (별도의 함수 필요)
                console.log(`[${serverName}] ${nickname} 삭제 요청`);
                deleteCharacter(serverName, nickname);
                tagDiv.remove(); // DOM에서도 즉시 제거
            });

            tagDiv.appendChild(serverSpan);
            tagDiv.appendChild(nicknameSpan);
            tagDiv.appendChild(removeBtn);
            tagDiv.onclick = () => handleTagClick(serverName, nickname)

            return tagDiv;
        }

        function handleTagClick(serverName, nickname) {
            SERVER_ID = serverData.find((server) => server.serverName === serverName).serverId;
            charInput.value = nickname;
            startSearch();
        }

        function deleteCharacter(serverName, nickname) {
            const transaction = db.transaction([CHARACTER_STORE], 'readwrite');
            const store = transaction.objectStore(CHARACTER_STORE);

            const getReq = store.get(DEFAULT_ID);

            getReq.onsuccess = (event) => {
                const characterObject = event.target.result;

                const character = characterObject[serverName][nickname];
                if (character) {
                    delete characterObject[serverName][nickname];
                    store.put(character, DEFAULT_ID);
                }
            }

            getReq.onerror = (event) => {
                console.error(`캐릭터 리스트 삭제 실패`, event);
            };
        }

        // 페이지 로드 시 DB 연결 시작
        openDatabase();

        function getAllItemDetails() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([ITEM_STORE], 'readonly');
                const store = transaction.objectStore(ITEM_STORE);

                const getReq = store.get(DEFAULT_ID);

                getReq.onsuccess = (event) => {
                    const itemObject = event.target.result || {};

                    if (itemObject) {
                        resolve(itemObject);
                    } else {
                        reject('아이템 상세정보가 비었습니다.');
                    }
                }

                getReq.onerror = (event) => {
                    console.error(`아이템 상세정보 조회 실패`, event);
                    reject(`아이템 상세정보 조회 실패`, event.target.error)
                };
            });
        }

        function getItemDetail(itemId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([ITEM_STORE], 'readonly');
                const store = transaction.objectStore(ITEM_STORE);

                const getReq = store.get(DEFAULT_ID);

                getReq.onsuccess = (event) => {
                    const itemObject = event.target.result || {};

                    const item = itemObject[itemId];
                    if (item) {
                        resolve(item);
                    } else {
                        reject('아이템 상세정보가 비었습니다.');
                    }
                }

                getReq.onerror = (event) => {
                    console.error(`아이템 상세정보 조회 실패`, event);
                    reject(`아이템 상세정보 조회 실패`, event.target.error)
                };
            });
        }

        function getAllItemIds() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([ITEM_STORE], 'readonly');
                const store = transaction.objectStore(ITEM_STORE);

                const getReq = store.get(DEFAULT_ID);

                getReq.onsuccess = (event) => {
                    const itemObject = event.target.result || {};

                    resolve(Object.keys(itemObject));
                }

                getReq.onerror = (event) => {
                    console.error(`아이템 상세정보 조회 실패`, event);
                    reject(`아이템 상세정보 조회 실패`, event.target.error)
                };
            });
        }

        function setItemDetail(itemData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([ITEM_STORE], 'readwrite');
                const store = transaction.objectStore(ITEM_STORE);

                const getReq = store.get(DEFAULT_ID);

                getReq.onsuccess = (event) => {
                    const itemObject = event.target.result || {};

                    const result = { ...itemObject, [itemData.itemId]: itemData };

                    const putReq = store.put(result, DEFAULT_ID);

                    putReq.onsuccess = (event) => {
                        resolve(event.target.result);
                    }

                    putReq.onerror = (event) => {
                        console.error(`아이템 상세정보 저장 실패`, event);
                        reject(`아이템 상세정보 저장 실패`, event.target.error);
                    };
                }

                getReq.onerror = (event) => {
                    console.error(`아이템 상세정보 저장 실패`, event);
                    reject(`아이템 상세정보 저장 실패`, event.target.error);
                };
            });
        }

        /**
         * 배열 A에서 배열 B와 겹치는 원소를 제거한 새로운 배열 (A - B)을 반환합니다.
         * @param {Array} arrA 기준이 되는 배열
         * @param {Array} arrB 제거할 원소를 포함하는 배열
         * @returns {Array} 차집합 결과 배열
         */
        function arrayDifference(arrA, arrB) {
            // 1. 배열 B를 Set으로 변환하여 검색 속도를 O(1)로 만듭니다.
            const setB = new Set(arrB);

            // 2. 배열 A를 순회하며 Set B에 없는 원소만 필터링합니다.
            return arrA.filter(item => !setB.has(item));
        }

        function getTimelines(characterId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TIMELINE_STORE], 'readonly');
                const store = transaction.objectStore(TIMELINE_STORE);

                const getReq = store.get(DEFAULT_ID);

                getReq.onsuccess = (event) => {
                    const timelineObject = event.target.result || {};

                    const timelines = timelineObject[characterId];
                    if (timelines) {
                        resolve(timelines);
                    } else {
                        resolve([]);
                    }
                }

                getReq.onerror = (event) => {
                    console.error(`타임라인 조회 실패`, event);
                    reject(`타임라인 조회 실패`, event.target.error)
                };
            });
        }

        function setTimelines(characterId, timelines) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TIMELINE_STORE], 'readwrite');
                const store = transaction.objectStore(TIMELINE_STORE);

                const getReq = store.get(DEFAULT_ID);

                getReq.onsuccess = (event) => {
                    const timelineObject = event.target.result || {};

                    const putReq = store.put({ ...timelineObject, [characterId]: timelines }, DEFAULT_ID);

                    putReq.onsuccess = (event) => {
                        resolve(event.target.result);
                    }
                }

                getReq.onerror = (event) => {
                    console.error(`타임라인 조회 실패`, event);
                    reject(`타임라인 조회 실패`, event.target.error)
                };
            });
        }

        document.querySelector('.control-buttons').addEventListener('click', (event) => {
            const targetButton = event.target;
            if (!targetButton.classList.contains('select-btn')) return;

            const allCheckboxes = document.querySelectorAll('#setCheckboxList input[type="checkbox"]');

            if (targetButton.classList.contains('select-all-btn')) {
                // 전체 선택
                allCheckboxes.forEach(cb => cb.checked = true);
                filterTimeline();
                return;
            }

            if (targetButton.classList.contains('deselect-all-btn')) {
                // 전체 해제
                allCheckboxes.forEach(cb => cb.checked = false);
                filterTimeline();
                return;
            }

            // ⭐️ 특정 그룹 선택 로직 ⭐️
            const singleTargetGroup = targetButton.dataset.target; // 버튼의 단일 타겟 그룹 (예: "group-a")

            if (singleTargetGroup) {
                allCheckboxes.forEach(cb => {
                    // 1. 체크박스의 복수 그룹 문자열을 가져와 공백으로 분리하여 배열로 만듭니다.
                    const checkboxGroups = cb.dataset.group ? cb.dataset.group.split(' ') : [];

                    // 2. 체크박스 그룹 배열에 버튼의 단일 타겟 그룹이 포함되어 있는지 확인합니다.
                    if (checkboxGroups.includes(singleTargetGroup)) {
                        // 해당 체크박스가 타겟 그룹 중 하나라도 포함하고 있으면 선택
                        cb.checked = true;
                    } else {
                        // 타겟 그룹에 속하지 않으면 해제
                        cb.checked = false;
                    }
                });
            } else if (targetButton.id === 'select-only-mine' && mySet) {
                allCheckboxes.forEach(cb => {
                    if (cb.textContent.trim() === mySet) {
                        cb.checked = true;
                    } else {
                        cb.checked = false;
                    }
                });
            }
            filterTimeline();
        });
    </script>

</body>

</html>